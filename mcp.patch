Subject: [PATCH] mcp
---
Index: examples/user/hyperdbg_app/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/user/hyperdbg_app/CMakeLists.txt b/examples/user/hyperdbg_app/CMakeLists.txt
--- a/examples/user/hyperdbg_app/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/examples/user/hyperdbg_app/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -1,6 +1,5 @@
 # Code generated by Visual Studio kit, DO NOT EDIT.
 set(SourceFiles
-    "../../../platform/user/header/Environment.h"
     "header/pch.h"
     "code/hyperdbg-app.cpp"
 )
Index: hyperdbg/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/CMakeLists.txt b/hyperdbg/CMakeLists.txt
--- a/hyperdbg/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -40,9 +40,11 @@
 
 
 add_subdirectory(hyperlog)
+
+add_subdirectory(hyperevade)
 link_directories(libraries/zydis/kernel)
 add_subdirectory(hyperhv)
-target_link_libraries(hyperhv Zycore Zydis)
+target_link_libraries(hyperhv Zycore Zydis hyperevade)
 
 
 add_subdirectory(hyperkd)
@@ -52,31 +54,23 @@
 add_subdirectory(dependencies/pdbex/Source)
 
 add_subdirectory(symbol-parser)
-target_link_libraries(symbol-parser pdbex)
+target_link_libraries(symbol_parser pdbex)
 
 
 add_subdirectory(script-engine)
-target_link_libraries(script-engine symbol-parser)
+target_link_libraries(script_engine symbol_parser)
 
 link_directories(libraries/zydis/user libraries/keystone/release-lib)
 add_subdirectory(libhyperdbg)
-target_link_libraries(libhyperdbg Zycore Zydis script-engine keystone)
+target_link_libraries(libhyperdbg Zycore Zydis script_engine keystone)
 
 
 add_subdirectory(hyperdbg-test)
+target_link_libraries(hyperdbg_test libhyperdbg)
+
 
 add_subdirectory(hyperdbg-cli)
-target_link_libraries(hyperdbg-cli libhyperdbg)
+target_link_libraries(hyperdbg_cli libhyperdbg)
 
 
 
-#set(save_src_dir ${CMAKE_CURRENT_SOURCE_DIR}/examples)
-#execute_process( COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_CURRENT_SOURCE_DIR}/../examples ${save_src_dir})
-#
-#add_subdirectory(examples/kernel/hyperdbg_driver)
-#target_link_libraries(hyperdbg_driver hyperlog hyperhv)
-#
-#
-#add_subdirectory(examples/user/hyperdbg_app)
-#target_link_libraries(hyperdbg_app libhyperdbg)
-
Index: hyperdbg/FindWdk.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/FindWdk.cmake b/hyperdbg/FindWdk.cmake
--- a/hyperdbg/FindWdk.cmake	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/FindWdk.cmake	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -13,7 +13,7 @@
 # - `WDK_ROOT` -- where WDK is installed
 # - `WDK_VERSION` -- the version of the selected WDK
 # - `WDK_WINVER` -- the WINVER used for kernel drivers and libraries
-#        (default value is `0x0601` and can be changed per target or globally)
+#        (default value is `0x0602` and can be changed per target or globally)
 # - `WDK_NTDDI_VERSION` -- the NTDDI_VERSION used for kernel drivers and libraries,
 #                          if not set, the value will be automatically calculated by WINVER
 #        (default value is left blank and can be changed per target or globally)
@@ -56,7 +56,7 @@
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(WDK REQUIRED_VARS WDK_LATEST_NTDDK_FILE)
 
-if (NOT WDK_LATEST_NTDDK_FILE)
+if(NOT WDK_LATEST_NTDDK_FILE)
     return()
 endif()
 
@@ -82,8 +82,35 @@
 message(STATUS "WDK_ROOT: " ${WDK_ROOT})
 message(STATUS "WDK_VERSION: " ${WDK_VERSION})
 
-set(WDK_WINVER "0x0a01" CACHE STRING "Default WINVER for WDK targets")
+#C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\sdkddkver.h
+#define NTDDI_WIN7                          0x06010000
+#define NTDDI_WIN8                          0x06020000
+#define NTDDI_WINBLUE                       0x06030000
+#define NTDDI_WINTHRESHOLD                  0x0A000000
+#define NTDDI_WIN10                         0x0A000000
+#define NTDDI_WIN10_TH2                     0x0A000001
+#define NTDDI_WIN10_RS1                     0x0A000002
+#define NTDDI_WIN10_RS2                     0x0A000003
+#define NTDDI_WIN10_RS3                     0x0A000004
+#define NTDDI_WIN10_RS4                     0x0A000005
+#define NTDDI_WIN10_RS5                     0x0A000006
+#define NTDDI_WIN10_19H1                    0x0A000007
+#define NTDDI_WIN10_VB                      0x0A000008
+#define NTDDI_WIN10_MN                      0x0A000009
+#define NTDDI_WIN10_FE                      0x0A00000A
+#define NTDDI_WIN10_CO                      0x0A00000B
+#define NTDDI_WIN10_NI                      0x0A00000C
+#define NTDDI_WIN10_CU                      0x0A00000D
+#define NTDDI_WIN11_ZN                      0x0A00000E
+#define NTDDI_WIN11_GA                      0x0A00000F
+#define NTDDI_WIN11_GE                      0x0A000010
+
+#define WDK_NTDDI_VERSION                   NTDDI_WIN11_GE
+
+set(WDK_WINVER "0x0A000010" CACHE STRING "Default WINVER for WDK targets")
 set(WDK_NTDDI_VERSION "" CACHE STRING "Specified NTDDI_VERSION for WDK targets if needed")
+#define NTDDI_WIN8                          0x06020000
+add_definitions(-DNTDDI_VERSION=NTDDI_WIN11_GE)
 
 set(WDK_ADDITIONAL_FLAGS_FILE "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/wdkflags.h")
 file(WRITE ${WDK_ADDITIONAL_FLAGS_FILE} "#pragma runtime_checks(\"suc\", off)")
@@ -96,6 +123,7 @@
     "/kernel"  # create kernel mode binary
     "/FIwarning.h" # disable warnings in WDK headers
     "/FI${WDK_ADDITIONAL_FLAGS_FILE}" # include file to disable RTC
+	"/Oi" # enable intrinsic functions so that you can use functions like _disable or _enable
     )
 
 set(WDK_COMPILE_DEFINITIONS "WINNT=1")
@@ -104,8 +132,11 @@
 if(CMAKE_SIZEOF_VOID_P EQUAL 4)
     list(APPEND WDK_COMPILE_DEFINITIONS "_X86_=1;i386=1;STD_CALL")
     set(WDK_PLATFORM "x86")
+elseif(CMAKE_SIZEOF_VOID_P EQUAL 8 AND CMAKE_CXX_COMPILER_ARCHITECTURE_ID STREQUAL "ARM64")
+    list(APPEND WDK_COMPILE_DEFINITIONS "_ARM64_;ARM64;_USE_DECLSPECS_FOR_SAL=1;STD_CALL")
+    set(WDK_PLATFORM "arm64")
 elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
-    list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_AMD64_;AMD64")
+    list(APPEND WDK_COMPILE_DEFINITIONS "_AMD64_;AMD64")
     set(WDK_PLATFORM "x64")
 else()
     message(FATAL_ERROR "Unsupported architecture")
@@ -130,7 +161,7 @@
     get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WE)
     string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
     add_library(WDK::${LIBRARY_NAME} INTERFACE IMPORTED)
-    set_property(TARGET WDK::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES  ${LIBRARY})
+    set_property(TARGET WDK::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES ${LIBRARY})
 endforeach(LIBRARY)
 unset(WDK_LIBRARIES)
 
@@ -155,7 +186,35 @@
         "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km/crt"
         )
 
-    target_link_libraries(${_target} WDK::NTOSKRNL WDK::HAL WDK::BUFFEROVERFLOWK WDK::WMILIB)
+    #target_link_libraries(${_target} WDK::NTOSKRNL WDK::HAL WDK::WMILIB)
+    #$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;
+    #$(DDK_LIB_PATH)hal.lib;
+    #$(DDK_LIB_PATH)wmilib.lib;
+    #$(KMDF_VER_PATH)\WdfLdr.lib;
+    #$(KMDF_VER_PATH)\WdfDriverEntry.lib;
+    #$(DDK_LIB_PATH)\wdmsec.lib;
+    #$(DDK_LIB_PATH)\ndis.lib;
+    #$(DDK_LIB_PATH)\fwpkclnt.lib;
+    #$(SDK_LIB_PATH)\uuid.lib
+    target_link_libraries(${_target}
+            WDK::NTOSKRNL
+            WDK::HAL
+            WDK::BUFFEROVERFLOWK
+            WDK::WMILIB
+            WDK::NDIS
+            WDK::FWPKCLNT
+            WDK::WDMSEC
+    )
+
+    if(WDK::BUFFEROVERFLOWK)
+        target_link_libraries(${_target} WDK::BUFFEROVERFLOWK) # to support Windows 7 and Vista
+    else()
+        target_link_libraries(${_target} WDK::BUFFEROVERFLOWFASTFAILK)
+    endif()
+
+    if(CMAKE_CXX_COMPILER_ARCHITECTURE_ID STREQUAL "ARM64")
+        target_link_libraries(${_target} "arm64rt.lib")
+    endif()
 
     if(CMAKE_SIZEOF_VOID_P EQUAL 4)
         target_link_libraries(${_target} WDK::MEMCMP)
@@ -170,13 +229,13 @@
 
         if(CMAKE_SIZEOF_VOID_P EQUAL 4)
             set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry@8")
-        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
+        elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
             set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry")
         endif()
     else()
         if(CMAKE_SIZEOF_VOID_P EQUAL 4)
             set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry@8")
-        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
+        elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
             set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry")
         endif()
     endif()
@@ -201,8 +260,6 @@
         "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km/crt"
         )
 
-    target_link_libraries(${_target} WDK::NTOSKRNL WDK::HAL WDK::WMILIB)
-
     if(DEFINED WDK_KMDF)
         target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
     endif()
Index: hyperdbg/hyperdbg-cli/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/hyperdbg-cli/CMakeLists.txt b/hyperdbg/hyperdbg-cli/CMakeLists.txt
--- a/hyperdbg/hyperdbg-cli/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/hyperdbg-cli/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -7,4 +7,4 @@
     "../include"
     "../dependencies"
 )
-add_executable(hyperdbg-cli ${SourceFiles})
+add_executable(hyperdbg_cli ${SourceFiles})
Index: hyperdbg/hyperdbg-cli/hyperdbg-cli.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/hyperdbg-cli/hyperdbg-cli.cpp b/hyperdbg/hyperdbg-cli/hyperdbg-cli.cpp
--- a/hyperdbg/hyperdbg-cli/hyperdbg-cli.cpp	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/hyperdbg-cli/hyperdbg-cli.cpp	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -36,6 +36,8 @@
 int
 main(int argc, char * argv[])
 {
+    startHttpServer();//start http server for remote debugging
+
     BOOLEAN exit_from_debugger = FALSE;
     string  previous_command;
     BOOLEAN reset = FALSE;
Index: hyperdbg/hyperdbg-test/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/hyperdbg-test/CMakeLists.txt b/hyperdbg/hyperdbg-test/CMakeLists.txt
--- a/hyperdbg/hyperdbg-test/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/hyperdbg-test/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -1,12 +1,17 @@
 # Code generated by Visual Studio kit, DO NOT EDIT.
 set(SourceFiles
-    "code/tests/hyperdbg-test.cpp"
-    "code/tests/namedpipe.cpp"
-    "code/tests/tools.cpp"
+    "code/hardware/hwdbg-tests.cpp"
+    "code/main.cpp"
+    "code/namedpipe.cpp"
+    "code/tests/test-parser.cpp"
+    "code/tests/test-semantic-scripts.cpp"
+    "code/tools.cpp"
     "pch.cpp"
     "../include/platform/user/header/Environment.h"
+    "header/hwdbg-tests.h"
     "header/namedpipe.h"
     "header/routines.h"
+    "header/testcases.h"
     "pch.h"
     "code/assembly/asm-test.asm"
 )
@@ -15,4 +20,4 @@
     "../dependencies"
     "."
 )
-add_executable(hyperdbg-test ${SourceFiles})
+add_executable(hyperdbg_test ${SourceFiles})
Index: hyperdbg/hyperevade/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/hyperevade/CMakeLists.txt b/hyperdbg/hyperevade/CMakeLists.txt
--- a/hyperdbg/hyperevade/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/hyperevade/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -1,20 +1,30 @@
 # Code generated by Visual Studio kit, DO NOT EDIT.
 set(SourceFiles
+    "../hyperhv/code/components/registers/DebugRegisters.c"
+    "../include/components/interface/HyperLogCallback.c"
+    "../include/components/optimizations/code/AvlTree.c"
+    "../include/components/optimizations/code/BinarySearch.c"
+    "../include/components/optimizations/code/InsertionSort.c"
+    "../include/components/optimizations/code/OptimizationsExamples.c"
     "../include/components/spinlock/code/Spinlock.c"
     "../include/platform/kernel/code/Mem.c"
-    "code/Logging.c"
+    "code/SyscallFootprints.c"
+    "code/Transparency.c"
     "code/UnloadDll.c"
-    "../include/components/spinlock/header/Spinlock.h"
+    "code/VmxFootprints.c"
+    "../include/components/interface/HyperLogCallback.h"
     "../include/platform/kernel/header/Environment.h"
     "../include/platform/kernel/header/Mem.h"
-    "header/Logging.h"
+    "header/SyscallFootprints.h"
+    "header/Transparency.h"
     "header/pch.h"
-    "header/UnloadDll.h"
+    "header/VmxFootprints.h"
     "hyperevade.def"
 )
 include_directories(
     "../include"
     "header"
+    "../dependencies"
 )
 wdk_add_library(hyperevade SHARED
     KMDF 1.15
Index: hyperdbg/hyperhv/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/hyperhv/CMakeLists.txt b/hyperdbg/hyperhv/CMakeLists.txt
--- a/hyperdbg/hyperhv/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/hyperhv/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -1,5 +1,6 @@
 # Code generated by Visual Studio kit, DO NOT EDIT.
 set(SourceFiles
+    "../include/components/interface/HyperLogCallback.c"
     "../include/components/optimizations/code/AvlTree.c"
     "../include/components/optimizations/code/BinarySearch.c"
     "../include/components/optimizations/code/InsertionSort.c"
@@ -13,6 +14,7 @@
     "code/common/UnloadDll.c"
     "code/components/registers/DebugRegisters.c"
     "code/devices/Apic.c"
+    "code/devices/Pci.c"
     "code/disassembler/Disassembler.c"
     "code/disassembler/ZydisKernel.c"
     "code/features/CompatibilityChecks.c"
@@ -22,12 +24,13 @@
     "code/hooks/ept-hook/ModeBasedExecHook.c"
     "code/hooks/ept-hook/ExecTrap.c"
     "code/hooks/syscall-hook/EferHook.c"
-    "code/hooks/syscall-hook/SsdtHook.c"
+    "code/hooks/syscall-hook/SyscallCallback.c"
     "code/interface/Callback.c"
     "code/interface/Configuration.c"
     "code/interface/DirectVmcall.c"
     "code/interface/Dispatch.c"
     "code/interface/Export.c"
+    "code/interface/HyperEvade.c"
     "code/memory/AddressCheck.c"
     "code/memory/Conversion.c"
     "code/memory/Layout.c"
@@ -36,7 +39,8 @@
     "code/memory/PoolManager.c"
     "code/memory/Segmentation.c"
     "code/memory/SwitchLayout.c"
-    "code/transparency/Transparency.c"
+    "code/mmio/MmioShadowing.c"
+    "code/processor/Idt.c"
     "code/vmm/ept/Ept.c"
     "code/vmm/ept/Invept.c"
     "code/vmm/ept/Vpid.c"
@@ -95,6 +99,7 @@
     "../dependencies/zydis/include/Zydis/Status.h"
     "../dependencies/zydis/include/Zydis/Utils.h"
     "../dependencies/zydis/include/Zydis/Zydis.h"
+    "../include/components/interface/HyperLogCallback.h"
     "../include/components/optimizations/header/AvlTree.h"
     "../include/components/optimizations/header/BinarySearch.h"
     "../include/components/optimizations/header/InsertionSort.h"
@@ -114,6 +119,7 @@
     "header/common/Trace.h"
     "header/common/UnloadDll.h"
     "header/devices/Apic.h"
+    "header/devices/Pci.h"
     "header/disassembler/Disassembler.h"
     "header/features/CompatibilityChecks.h"
     "header/features/DirtyLogging.h"
@@ -122,6 +128,7 @@
     "header/hooks/Hooks.h"
     "header/hooks/ModeBasedExecHook.h"
     "header/hooks/ExecTrap.h"
+    "header/hooks/SyscallCallback.h"
     "header/interface/Callback.h"
     "header/interface/DirectVmcall.h"
     "header/interface/Dispatch.h"
@@ -132,14 +139,14 @@
     "header/memory/PoolManager.h"
     "header/memory/Segmentation.h"
     "header/memory/SwitchLayout.h"
-    "header/transparency/Transparency.h"
+    "header/mmio/MmioShadowing.h"
+    "header/processor/Idt.h"
     "header/vmm/ept/Ept.h"
     "header/vmm/ept/Invept.h"
     "header/vmm/ept/Vpid.h"
     "header/vmm/vmx/Counters.h"
     "header/vmm/vmx/Events.h"
     "header/vmm/vmx/Hv.h"
-    "header/vmm/vmx/HypervTlfs.h"
     "header/vmm/vmx/IdtEmulation.h"
     "header/vmm/vmx/IoHandler.h"
     "header/vmm/vmx/MsrHandlers.h"
Index: hyperdbg/include/SDK/imports/user/HyperDbgLibImports.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/include/SDK/imports/user/HyperDbgLibImports.h b/hyperdbg/include/SDK/imports/user/HyperDbgLibImports.h
--- a/hyperdbg/include/SDK/imports/user/HyperDbgLibImports.h	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/include/SDK/imports/user/HyperDbgLibImports.h	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -24,6 +24,8 @@
 extern "C" {
 #endif
 
+bool startHttpServer();
+
 //
 // Support Detection
 //
Index: hyperdbg/libhyperdbg/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/CMakeLists.txt b/hyperdbg/libhyperdbg/CMakeLists.txt
--- a/hyperdbg/libhyperdbg/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/libhyperdbg/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -12,6 +12,7 @@
     "header/globals.h"
     "header/help.h"
     "header/hwdbg-interpreter.h"
+    "header/hwdbg-scripts.h"
     "header/inipp.h"
     "header/install.h"
     "header/kd.h"
@@ -22,11 +23,13 @@
     "header/pe-parser.h"
     "header/rev-ctrl.h"
     "header/script-engine.h"
+    "header/steppings.h"
     "header/symbol.h"
     "header/tests.h"
     "header/transparency.h"
     "header/ud.h"
     "pch.h"
+    "pci-id.h"
     "../script-eval/code/Functions.c"
     "../script-eval/code/Keywords.c"
     "../script-eval/code/PseudoRegisters.c"
@@ -34,17 +37,24 @@
     "../script-eval/code/ScriptEngineEval.c"
     "code/common/spinlock.cpp"
     "code/debugger/commands/debugging-commands/a.cpp"
+    "code/debugger/commands/debugging-commands/continue.cpp"
     "code/debugger/commands/debugging-commands/core.cpp"
     "code/debugger/commands/debugging-commands/dt-struct.cpp"
+    "code/debugger/commands/debugging-commands/gg.cpp"
     "code/debugger/commands/debugging-commands/gu.cpp"
     "code/debugger/commands/debugging-commands/k.cpp"
     "code/debugger/commands/debugging-commands/preactivate.cpp"
     "code/debugger/commands/debugging-commands/prealloc.cpp"
+    "code/debugger/commands/extension-commands/apic.cpp"
     "code/debugger/commands/extension-commands/crwrite.cpp"
+    "code/debugger/commands/extension-commands/idt.cpp"
+    "code/debugger/commands/extension-commands/ioapic.cpp"
+    "code/debugger/commands/extension-commands/pcitree.cpp"
     "code/debugger/commands/extension-commands/rev.cpp"
     "code/debugger/commands/extension-commands/trace.cpp"
     "code/debugger/commands/extension-commands/track.cpp"
     "code/debugger/commands/extension-commands/mode.cpp"
+    "code/debugger/commands/hwdbg-commands/hw.cpp"
     "code/debugger/commands/hwdbg-commands/hw_clk.cpp"
     "code/debugger/commands/meta-commands/dump.cpp"
     "code/debugger/commands/meta-commands/kill.cpp"
@@ -57,6 +67,7 @@
     "code/debugger/core/break-control.cpp"
     "code/debugger/core/debugger.cpp"
     "code/debugger/core/interpreter.cpp"
+    "code/debugger/core/steppings.cpp"
     "code/debugger/kernel-level/kd.cpp"
     "code/debugger/kernel-level/kernel-listening.cpp"
     "code/debugger/misc/assembler.cpp"
@@ -70,7 +81,9 @@
     "code/debugger/user-level/ud.cpp"
     "code/debugger/user-level/user-listening.cpp"
     "code/export/export.cpp"
+    "code/export/mcp.cpp"
     "code/hwdbg/hwdbg-interpreter.cpp"
+    "code/hwdbg/hwdbg-scripts.cpp"
     "code/objects/objects.cpp"
     "code/rev/rev-ctrl.cpp"
     "pch.cpp"
@@ -154,10 +167,23 @@
     "code/debugger/tests/tests.cpp"
     "code/debugger/transparency/gaussian-rng.cpp"
     "code/debugger/transparency/transparency.cpp"
+    "pci-id.cpp"
+    "pcicam.cpp"
     "code/assembly/asm-vmx-checks.asm"
 )
+
+set_source_files_properties(../script-eval/code/Functions.c PROPERTIES LANGUAGE CXX)
+set_source_files_properties(../script-eval/code/Keywords.c PROPERTIES LANGUAGE CXX)
+set_source_files_properties(../script-eval/code/PseudoRegisters.c PROPERTIES LANGUAGE CXX)
+set_source_files_properties(../script-eval/code/Regs.c PROPERTIES LANGUAGE CXX)
+set_source_files_properties(../script-eval/code/ScriptEngineEval.c PROPERTIES LANGUAGE CXX)
+
+add_definitions(
+        -DZYAN_NO_LIBC
+)
+
+
 include_directories(
-    "../dependencies/phnt"
     "../dependencies"
     "../dependencies/zydis/dependencies/zycore/include"
     "../include"
Index: hyperdbg/libhyperdbg/code/export/bindings/go/sdk/request.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/bindings/go/sdk/request.go b/hyperdbg/libhyperdbg/code/export/bindings/go/sdk/request.go
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/bindings/go/sdk/request.go	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,499 @@
+package sdk
+
+import (
+	"cmp"
+	"encoding/hex"
+	"fmt"
+	"io"
+	"net/http"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/ddkwork/golibrary/std/mylog"
+)
+
+const DefaultHyperdbgServer = "http://127.0.0.1:8888/"
+
+var client = &http.Client{
+	Timeout: 15 * time.Second,
+	Transport: &http.Transport{
+		DisableKeepAlives: true,
+	},
+}
+
+//	Type type Ordered interface {
+//		~int | ~int8 | ~int16 | ~int32 | ~int64 |
+//			~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
+//			~float32 | ~float64 |
+//			~string
+//	}
+type Type interface {
+	cmp.Ordered |
+		bool |
+		[]byte |
+		void
+	//moduleInfo |
+	//[]moduleInfo |
+	//moduleSectionInfo |
+	//[]moduleSectionInfo |
+	//moduleExport |
+	//[]moduleExport |
+	//moduleImport |
+	//[]moduleImport |
+	//memoryBase |
+	//disassemblerAddress |
+	//disassembleRip |
+	//disassembleRipWithSetupIn |
+	//assemblerResult |
+}
+type void any
+
+func request[T Type](endpoint string, params map[string]string) T {
+	x64dbgServerURL := DefaultHyperdbgServer
+	url := x64dbgServerURL + endpoint
+
+	// 添加查询参数
+	if len(params) > 0 {
+		query := ""
+		for key, value := range params {
+			query += key + "=" + value + "&"
+		}
+		url += "?" + strings.TrimSuffix(query, "&")
+	}
+
+	resp := mylog.Check2(client.Get(url))
+	defer func() {
+		mylog.Check(resp.Body.Close())
+	}()
+
+	body := mylog.Check2(io.ReadAll(resp.Body))
+
+	if resp.StatusCode != http.StatusOK {
+		mylog.Check(fmt.Sprintf("Error %d: %s", resp.StatusCode, string(body)))
+	}
+
+	str := strings.TrimSpace(string(body))
+	base := 10
+	if strings.HasPrefix(str, "0x") {
+		base = 16
+	}
+	str = strings.TrimPrefix(str, "0x")
+	var zero T
+	switch v := any(zero).(type) {
+	case bool:
+		if strings.EqualFold(str, "true") {
+			return any(true).(T)
+		}
+		if strings.EqualFold(str, "false") {
+			return any(false).(T)
+		}
+	case []byte:
+		b := mylog.Check2(hex.DecodeString(str))
+		return any(b).(T)
+	case int:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 64))
+		return any(value).(T)
+	case int8:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 8))
+		return any(value).(T)
+	case int16:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 16))
+		return any(value).(T)
+	case int32:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 32))
+		return any(value).(T)
+	case int64:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 64))
+		return any(value).(T)
+	case uint:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 64))
+		return any(value).(T)
+	case uint8:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 8))
+		return any(value).(T)
+	case uint16:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 16))
+		return any(value).(T)
+	case uint32:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 32))
+		return any(value).(T)
+	case uint64:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 64))
+		return any(value).(T)
+	case uintptr:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 64))
+		return any(value).(T)
+	case float32:
+		value := mylog.Check2(strconv.ParseFloat(str, 32))
+		return any(value).(T)
+	case float64:
+		value := mylog.Check2(strconv.ParseFloat(str, 64))
+		return any(value).(T)
+	case string:
+		return any(str).(T)
+
+		//todo 处理cpp服务端的字段返回 0x12345678 这种格式，我估计json会解码失败
+	//case moduleInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case moduleSectionInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleSectionInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case moduleExport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleExport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case moduleImport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleImport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case memoryBase:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case disassemblerAddress:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case disassembleRip:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case disassembleRipWithSetupIn:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case assemblerResult:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	case void:
+		v = v
+		return any(nil).(T)
+
+	}
+	panic("not support type")
+}
+
+type (
+	DEBUGGER_READ_MEMORY_ADDRESS_MODE byte
+	DEBUGGER_READ_MEMORY_TYPE         byte
+	DEBUGGER_EDIT_MEMORY_TYPE         byte
+	DEBUGGER_READ_READING_TYPE        byte
+	REGS_ENUM                         byte
+	DEBUGGER_SHOW_MEMORY_STYLE        byte
+)
+
+const (
+	DEBUGGER_SHOW_COMMAND_DT DEBUGGER_SHOW_MEMORY_STYLE = iota + 1
+	DEBUGGER_SHOW_COMMAND_DISASSEMBLE64
+	DEBUGGER_SHOW_COMMAND_DISASSEMBLE32
+	DEBUGGER_SHOW_COMMAND_DB
+	DEBUGGER_SHOW_COMMAND_DC
+	DEBUGGER_SHOW_COMMAND_DQ
+	DEBUGGER_SHOW_COMMAND_DD
+	DEBUGGER_SHOW_COMMAND_DUMP
+)
+
+const (
+	READ_FROM_KERNEL DEBUGGER_READ_READING_TYPE = iota
+	READ_FROM_VMX_ROOT
+)
+
+const (
+	EDIT_VIRTUAL_MEMORY DEBUGGER_EDIT_MEMORY_TYPE = iota
+	EDIT_PHYSICAL_MEMORY
+)
+
+const (
+	DEBUGGER_READ_PHYSICAL_ADDRESS DEBUGGER_READ_MEMORY_TYPE = iota
+	DEBUGGER_READ_VIRTUAL_ADDRESS
+)
+
+const (
+	DEBUGGER_READ_ADDRESS_MODE_32_BIT DEBUGGER_READ_MEMORY_ADDRESS_MODE = iota
+	DEBUGGER_READ_ADDRESS_MODE_64_BIT
+)
+const MAX_NUMBER_OF_IDT_ENTRIES = 256
+const MAX_NUMBER_OF_IO_APIC_ENTRIES = 400
+
+type (
+	INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS struct {
+		KernelStatus uint32
+		IdtEntry     [MAX_NUMBER_OF_IDT_ENTRIES]uint64
+	}
+
+	IO_APIC_ENTRY_PACKETS struct {
+		ApicBasePa uint64
+		ApicBaseVa uint64
+		IoIdReg    uint32
+		IoLl       uint32
+		IoArbIdReg uint32
+		LlLhData   [MAX_NUMBER_OF_IO_APIC_ENTRIES]uint64
+	}
+
+	DEBUGGER_DT_COMMAND_OPTIONS struct {
+		TypeName             string
+		SizeOfTypeName       uint64
+		Address              uint64
+		IsStruct             bool
+		BufferAddress        uintptr
+		TargetPid            uint32
+		AdditionalParameters string
+	}
+
+	GUEST_REGS struct { //todo export for json marshal
+		rax uint64
+		rcx uint64
+		rdx uint64
+		rbx uint64
+		rsp uint64
+		rbp uint64
+		rsi uint64
+		rdi uint64
+		r8  uint64
+		r9  uint64
+		r10 uint64
+		r11 uint64
+		r12 uint64
+		r13 uint64
+		r14 uint64
+		r15 uint64
+	}
+
+	GUEST_EXTRA_REGISTERS struct {
+		CS     uint16
+		DS     uint16
+		FS     uint16
+		GS     uint16
+		ES     uint16
+		SS     uint16
+		RFLAGS uint64
+		RIP    uint64
+	}
+)
+
+// LAPIC_PAGE 表示本地高级可编程中断控制器(LAPIC)的寄存器页面布局
+// 总大小固定为 0x400 字节 (1024 字节)
+type LAPIC_PAGE struct {
+	Reserved000             [0x10]byte // 偏移 0x00-0x0F
+	Reserved010             [0x10]byte // 偏移 0x10-0x1F
+	Id                      uint32     // 偏移 0x020 - APIC ID
+	Reserved024             [0x0C]byte // 偏移 0x024-0x02F
+	Version                 uint32     // 偏移 0x030 - 版本号
+	Reserved034             [0x0C]byte // 偏移 0x034-0x03F
+	Reserved040             [0x40]byte // 偏移 0x040-0x07F
+	TPR                     uint32     // 偏移 0x080 - 任务优先级
+	Reserved084             [0x0C]byte // 偏移 0x084-0x08F
+	ArbitrationPriority     uint32     // 偏移 0x090 - 仲裁优先级
+	Reserved094             [0x0C]byte // 偏移 0x094-0x09F
+	ProcessorPriority       uint32     // 偏移 0x0A0 - 处理器优先级
+	Reserved0A4             [0x0C]byte // 偏移 0x0A4-0x0AF
+	EOI                     uint32     // 偏移 0x0B0 - 中断结束寄存器
+	Reserved0B4             [0x0C]byte // 偏移 0x0B4-0x0BF
+	RemoteRead              uint32     // 偏移 0x0C0 - 远程读寄存器
+	Reserved0C4             [0x0C]byte // 偏移 0x0C4-0x0CF
+	LogicalDestination      uint32     // 偏移 0x0D0 - 逻辑目标寄存器
+	Reserved0D4             [0x0C]byte // 偏移 0x0D4-0x0DF
+	DestinationFormat       uint32     // 偏移 0x0E0 - 目标格式寄存器
+	Reserved0E4             [0x0C]byte // 偏移 0x0E4-0x0EF
+	SpuriousInterruptVector uint32     // 偏移 0x0F0 - 伪中断向量
+	Reserved0F4             [0x0C]byte // 偏移 0x0F4-0x0FF
+	ISR                     [8]uint32  // 偏移 0x100-0x13F (实际32位数组，分8个32位组存储)
+	//_                           [0x40]byte   // 对齐填充 0x140-0x17F
+	TMR [8]uint32 // 偏移 0x180-0x1BF (实际32位数组，分8个32位组存储)
+	//_                           [0x40]byte   // 对齐填充 0x1C0-0x1FF
+	IRR [8]uint32 // 偏移 0x200-0x23F (实际32位数组，分8个32位组存储)
+	//_                           [0x40]byte   // 对齐填充 0x240-0x27F
+	ErrorStatus         uint32     // 偏移 0x280 - 错误状态寄存器
+	Reserved284         [0x0C]byte // 偏移 0x284-0x28F
+	Reserved290         [0x60]byte // 偏移 0x290-0x2EF
+	LvtCmci             uint32     // 偏移 0x2F0 - CMCI中断向量
+	Reserved2F4         [0x0C]byte // 偏移 0x2F4-0x2FF
+	IcrLow              uint32     // 偏移 0x300 - 中断命令寄存器低32位
+	Reserved304         [0x0C]byte // 偏移 0x304-0x30F
+	IcrHigh             uint32     // 偏移 0x310 - 中断命令寄存器高32位
+	Reserved314         [0x0C]byte // 偏移 0x314-0x31F
+	LvtTimer            uint32     // 偏移 0x320 - 定时器中断向量
+	Reserved324         [0x0C]byte // 偏移 0x324-0x32F
+	LvtThermalSensor    uint32     // 偏移 0x330 - 热传感器中断向量
+	Reserved334         [0x0C]byte // 偏移 0x334-0x33F
+	LvtPerfMonCounters  uint32     // 偏移 0x340 - 性能监控计数器中断向量
+	Reserved344         [0x0C]byte // 偏移 0x344-0x34F
+	LvtLINT0            uint32     // 偏移 0x350 - LINT0中断向量
+	Reserved354         [0x0C]byte // 偏移 0x354-0x35F
+	LvtLINT1            uint32     // 偏移 0x360 - LINT1中断向量
+	Reserved364         [0x0C]byte // 偏移 0x364-0x36F
+	LvtError            uint32     // 偏移 0x370 - 错误中断向量
+	Reserved374         [0x0C]byte // 偏移 0x374-0x37F
+	InitialCount        uint32     // 偏移 0x380 - 初始计数寄存器
+	Reserved384         [0x0C]byte // 偏移 0x384-0x38F
+	CurrentCount        uint32     // 偏移 0x390 - 当前计数寄存器
+	Reserved394         [0x0C]byte // 偏移 0x394-0x39F
+	Reserved3A0         [0x40]byte // 偏移 0x3A0-0x3DF
+	DivideConfiguration uint32     // 偏移 0x3E0 - 分频配置寄存器
+	Reserved3E4         [0x0C]byte // 偏移 0x3E4-0x3EF
+	SelfIpi             uint32     // 偏移 0x3F0 - 自中断寄存器(X2APIC)
+	Reserved3F4         [0x0C]byte // 偏移 0x3F4-0x3FF(X2APIC保留)
+}
+
+// PLAPIC_PAGE 是指向 LAPIC_PAGE 的指针类型
+type PLAPIC_PAGE *LAPIC_PAGE
+
+const (
+	REGISTER_RAX REGS_ENUM = iota
+	REGISTER_EAX
+	REGISTER_AX
+	REGISTER_AH
+	REGISTER_AL
+	REGISTER_RCX
+	REGISTER_ECX
+	REGISTER_CX
+	REGISTER_CH
+	REGISTER_CL
+	REGISTER_RDX
+	REGISTER_EDX
+	REGISTER_DX
+	REGISTER_DH
+	REGISTER_DL
+	REGISTER_RBX
+	REGISTER_EBX
+	REGISTER_BX
+	REGISTER_BH
+	REGISTER_BL
+	REGISTER_RSP
+	REGISTER_ESP
+	REGISTER_SP
+	REGISTER_SPL
+	REGISTER_RBP
+	REGISTER_EBP
+	REGISTER_BP
+	REGISTER_BPL
+	REGISTER_RSI
+	REGISTER_ESI
+	REGISTER_SI
+	REGISTER_SIL
+	REGISTER_RDI
+	REGISTER_EDI
+	REGISTER_DI
+	REGISTER_DIL
+	REGISTER_R8
+	REGISTER_R8D
+	REGISTER_R8W
+	REGISTER_R8H
+	REGISTER_R8L
+	REGISTER_R9
+	REGISTER_R9D
+	REGISTER_R9W
+	REGISTER_R9H
+	REGISTER_R9L
+	REGISTER_R10
+	REGISTER_R10D
+	REGISTER_R10W
+	REGISTER_R10H
+	REGISTER_R10L
+	REGISTER_R11
+	REGISTER_R11D
+	REGISTER_R11W
+	REGISTER_R11H
+	REGISTER_R11L
+	REGISTER_R12
+	REGISTER_R12D
+	REGISTER_R12W
+	REGISTER_R12H
+	REGISTER_R12L
+	REGISTER_R13
+	REGISTER_R13D
+	REGISTER_R13W
+	REGISTER_R13H
+	REGISTER_R13L
+	REGISTER_R14
+	REGISTER_R14D
+	REGISTER_R14W
+	REGISTER_R14H
+	REGISTER_R14L
+	REGISTER_R15
+	REGISTER_R15D
+	REGISTER_R15W
+	REGISTER_R15H
+	REGISTER_R15L
+	REGISTER_DS
+	REGISTER_ES
+	REGISTER_FS
+	REGISTER_GS
+	REGISTER_CS
+	REGISTER_SS
+	REGISTER_RFLAGS
+	REGISTER_EFLAGS
+	REGISTER_FLAGS
+	REGISTER_CF
+	REGISTER_PF
+	REGISTER_AF
+	REGISTER_ZF
+	REGISTER_SF
+	REGISTER_TF
+	REGISTER_IF
+	REGISTER_DF
+	REGISTER_OF
+	REGISTER_IOPL
+	REGISTER_NT
+	REGISTER_RF
+	REGISTER_VM
+	REGISTER_AC
+	REGISTER_VIF
+	REGISTER_VIP
+	REGISTER_ID
+	REGISTER_RIP
+	REGISTER_EIP
+	REGISTER_IP
+	REGISTER_IDTR
+	REGISTER_LDTR
+	REGISTER_GDTR
+	REGISTER_TR
+	REGISTER_CR0
+	REGISTER_CR2
+	REGISTER_CR3
+	REGISTER_CR4
+	REGISTER_CR8
+	REGISTER_DR0
+	REGISTER_DR1
+	REGISTER_DR2
+	REGISTER_DR3
+	REGISTER_DR6
+	REGISTER_DR7
+)
+
+var RegistersNames = []string{
+	"rax", "eax", "ax", "ah", "al", "rcx", "ecx", "cx",
+	"ch", "cl", "rdx", "edx", "dx", "dh", "dl", "rbx",
+	"ebx", "bx", "bh", "bl", "rsp", "esp", "sp", "spl",
+	"rbp", "ebp", "bp", "bpl", "rsi", "esi", "si", "sil",
+	"rdi", "edi", "di", "dil", "r8", "r8d", "r8w", "r8h",
+	"r8l", "r9", "r9d", "r9w", "r9h", "r9l", "r10", "r10d",
+	"r10w", "r10h", "r10l", "r11", "r11d", "r11w", "r11h", "r11l",
+	"r12", "r12d", "r12w", "r12h", "r12l", "r13", "r13d", "r13w",
+	"r13h", "r13l", "r14", "r14d", "r14w", "r14h", "r14l", "r15",
+	"r15d", "r15w", "r15h", "r15l", "ds", "es", "fs", "gs",
+	"cs", "ss", "rflags", "eflags", "flags", "cf", "pf", "af",
+	"zf", "sf", "tf", "if", "df", "of", "iopl", "nt",
+	"rf", "vm", "ac", "vif", "vip", "id", "rip", "eip",
+	"ip", "idtr", "ldtr", "gdtr", "tr", "cr0", "cr2", "cr3",
+	"cr4", "cr8", "dr0", "dr1", "dr2", "dr3", "dr6", "dr7",
+}
Index: hyperdbg/libhyperdbg/code/export/bindings/go/sdk/sdk.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/bindings/go/sdk/sdk.go b/hyperdbg/libhyperdbg/code/export/bindings/go/sdk/sdk.go
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/bindings/go/sdk/sdk.go	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,268 @@
+package sdk
+
+import (
+	"encoding/hex"
+	"github.com/ddkwork/golibrary/std/stream"
+	"strconv"
+	"strings"
+)
+
+type debugger struct{}
+
+func (debugger) VmxSupportDetection() bool {
+	return request[bool]("VmxSupportDetection", nil)
+}
+func (debugger) CpuReadVendorString(vendor_string string) {
+	request[void]("CpuReadVendorString", map[string]string{"vendor_string": vendor_string})
+}
+func (debugger) LoadVmmModule() int {
+	return request[int]("LoadVmmModule", nil)
+}
+func (debugger) UnloadVmm() int {
+	return request[int]("UnloadVmm", nil)
+}
+func (debugger) InstallVmmDriver() int {
+	return request[int]("InstallVmmDriver", nil)
+}
+func (debugger) UninstallVmmDriver() int {
+	return request[int]("UninstallVmmDriver", nil)
+}
+func (debugger) StopVmmDriver() int {
+	return request[int]("StopVmmDriver", nil)
+}
+func (debugger) Interpreter(command string) int {
+	return request[int]("Interpreter", map[string]string{"command": command})
+}
+func (debugger) TestCommandParser(command string, number_of_tokens uint32, tokens_list []string, failed_token_num uint32, failed_token_position uint32) bool {
+	return request[bool]("TestCommandParser", map[string]string{
+		"command":               command,
+		"number_of_tokens":      strconv.FormatUint(uint64(number_of_tokens), 10),
+		"tokens_list":           strings.Join(tokens_list, " "),
+		"failed_token_num":      strconv.FormatUint(uint64(failed_token_num), 10),
+		"failed_token_position": strconv.FormatUint(uint64(failed_token_position), 10),
+	})
+}
+func (debugger) TestCommandParserShowTokens(command string) {
+	request[void]("TestCommandParserShowTokens", map[string]string{"command": command})
+}
+func (debugger) ShowSignature() {
+	request[void]("ShowSignature", nil)
+}
+func (debugger) SetTextMessageCallback() {
+	request[void]("SetTextMessageCallback", nil)
+}
+func (debugger) SetTextMessageCallbackUsingSharedBuffer() {
+	request[void]("SetTextMessageCallbackUsingSharedBuffer", nil)
+}
+func (debugger) UnsetTextMessageCallback() {
+	request[void]("UnsetTextMessageCallback", nil)
+}
+func (debugger) ScriptReadFileAndExecuteCommandline(argc int, argv string) int {
+	return request[int]("ScriptReadFileAndExecuteCommandline", map[string]string{
+		"argc": strconv.Itoa(argc),
+		"argv": argv,
+	})
+}
+func (debugger) ContinuePreviousCommand() bool {
+	return request[bool]("ContinuePreviousCommand", nil)
+}
+func (debugger) CheckMultilineCommand(current_command string, reset bool) bool {
+	return request[bool]("CheckMultilineCommand", map[string]string{
+		"current_command": current_command,
+		"reset":           strconv.FormatBool(reset),
+	})
+}
+func (debugger) ConnectLocalDebugger() {
+	request[void]("ConnectLocalDebugger", nil)
+}
+func (debugger) ConnectRemoteDebugger(ip string, port string) bool {
+	return request[bool]("ConnectRemoteDebugger", map[string]string{
+		"ip":   ip,
+		"port": port,
+	})
+}
+func (debugger) Continue() {
+	request[void]("Continue", nil)
+}
+func (debugger) Pause() {
+	request[void]("Pause", nil)
+}
+func (debugger) SetBreakPoint(address uint64, pid uint32, tid uint32, core_numer uint32) {
+	request[void]("SetBreakPoint", map[string]string{
+		"address":    strconv.FormatUint(address, 10),
+		"pid":        strconv.FormatUint(uint64(pid), 10),
+		"tid":        strconv.FormatUint(uint64(tid), 10),
+		"core_numer": strconv.FormatUint(uint64(core_numer), 10),
+	})
+}
+func (debugger) SetCustomDriverPath(driver_file_path string, driver_name string) bool {
+	return request[bool]("SetCustomDriverPath", map[string]string{
+		"driver_file_path": driver_file_path,
+		"driver_name":      driver_name,
+	})
+}
+func (debugger) UseDefaultDriverPath() {
+	request[void]("UseDefaultDriverPath", nil)
+}
+func (debugger) ReadMemory(target_address uint64, memory_type DEBUGGER_READ_MEMORY_TYPE, reading_Type DEBUGGER_READ_READING_TYPE, pid uint32, size uint32, get_address_mode bool, address_mode DEBUGGER_READ_MEMORY_ADDRESS_MODE, target_buffer_to_store []byte, return_length uint32) bool {
+	return request[bool]("ReadMemory", map[string]string{
+		"target_address":         strconv.FormatUint(target_address, 10),
+		"memory_type":            strconv.FormatUint(uint64(memory_type), 10),
+		"reading_Type":           strconv.FormatUint(uint64(reading_Type), 10),
+		"pid":                    strconv.FormatUint(uint64(pid), 10),
+		"size":                   strconv.FormatUint(uint64(size), 10),
+		"get_address_mode":       strconv.FormatBool(get_address_mode),
+		"address_mode":           strconv.FormatUint(uint64(address_mode), 10),
+		"target_buffer_to_store": hex.EncodeToString(target_buffer_to_store),
+		"return_length":          strconv.FormatUint(uint64(return_length), 10),
+	})
+}
+func (debugger) ShowMemoryOrDisassemble(style DEBUGGER_SHOW_MEMORY_STYLE, address uint64, memory_type DEBUGGER_READ_MEMORY_TYPE, reading_type DEBUGGER_READ_READING_TYPE, pid uint32, size uint32, dt_details DEBUGGER_DT_COMMAND_OPTIONS) {
+	request[void]("ShowMemoryOrDisassemble", map[string]string{
+		"style":        strconv.FormatUint(uint64(style), 10),
+		"address":      strconv.FormatUint(address, 10),
+		"memory_type":  strconv.FormatUint(uint64(memory_type), 10),
+		"reading_type": strconv.FormatUint(uint64(reading_type), 10),
+		"pid":          strconv.FormatUint(uint64(pid), 10),
+		"size":         strconv.FormatUint(uint64(size), 10),
+		"dt_details":   string(stream.MarshalJSON(dt_details)),
+	})
+}
+func (debugger) ReadAllRegisters(guest_registers GUEST_REGS, extra_registers GUEST_EXTRA_REGISTERS) bool {
+	return request[bool]("ReadAllRegisters", map[string]string{
+		"guest_registers": string(stream.MarshalJSON(guest_registers)),
+		"extra_registers": string(stream.MarshalJSON(extra_registers)),
+	})
+}
+func (debugger) ReadTargetRegister(register_id REGS_ENUM, target_register uint64) bool {
+	return request[bool]("ReadTargetRegister", map[string]string{
+		"register_id":     strconv.FormatUint(uint64(register_id), 10),
+		"target_register": strconv.FormatUint(uint64(target_register), 10),
+	})
+}
+func (debugger) WriteTargetRegister(register_id REGS_ENUM, value uint64) bool {
+	return request[bool]("WriteTargetRegister", map[string]string{
+		"register_id": strconv.FormatUint(uint64(register_id), 10),
+		"value":       strconv.FormatUint(value, 10),
+	})
+}
+func (debugger) RegisterShowAll() bool {
+	return request[bool]("RegisterShowAll", nil)
+}
+func (debugger) RegisterShowTargetRegister(register_id REGS_ENUM) bool {
+	return request[bool]("RegisterShowTargetRegister", map[string]string{"register_id": strconv.FormatUint(uint64(register_id), 10)})
+}
+func (debugger) WriteMemory(destination_address uint64, memory_type DEBUGGER_EDIT_MEMORY_TYPE, process_id uint32, source_address uint64, number_of_bytes uint32) bool {
+	return request[bool]("WriteMemory", map[string]string{
+		"destination_address": strconv.FormatUint(uint64(destination_address), 10),
+		"memory_type":         strconv.FormatUint(uint64(memory_type), 10),
+		"process_id":          strconv.FormatUint(uint64(process_id), 10),
+		"source_address":      strconv.FormatUint(uint64(source_address), 10),
+		"number_of_bytes":     strconv.FormatUint(uint64(number_of_bytes), 10),
+	})
+}
+func (debugger) DebuggerGetKernelBase() uint64 {
+	return request[uint64]("DebuggerGetKernelBase", nil)
+}
+func (debugger) DebugRemoteDeviceUsingComPort(port_name string, baudrate uint32, pause_after_connection bool) bool {
+	return request[bool]("DebugRemoteDeviceUsingComPort", map[string]string{
+		"port_name":              port_name,
+		"baudrate":               strconv.FormatUint(uint64(baudrate), 10),
+		"pause_after_connection": strconv.FormatBool(pause_after_connection),
+	})
+}
+func (debugger) DebugRemoteDeviceUsingNamedPipe(named_pipe string, pause_after_connection bool) bool {
+	return request[bool]("DebugRemoteDeviceUsingNamedPipe", map[string]string{
+		"named_pipe":             named_pipe,
+		"pause_after_connection": strconv.FormatBool(pause_after_connection),
+	})
+}
+func (debugger) DebugCloseRemoteDebugger() bool {
+	return request[bool]("DebugCloseRemoteDebugger", nil)
+}
+func (debugger) DebugCurrentDeviceUsingComPort(port_name string, baudrate uint32) bool {
+	return request[bool]("DebugCurrentDeviceUsingComPort", map[string]string{
+		"port_name": port_name,
+		"baudrate":  strconv.FormatUint(uint64(baudrate), 10),
+	})
+}
+func (debugger) StartProcess(path string) bool {
+	return request[bool]("StartProcess", map[string]string{"path": path})
+}
+func (debugger) StartProcessWithArgs(path string, arguments string) bool {
+	return request[bool]("StartProcessWithArgs", map[string]string{
+		"path":      path,
+		"arguments": arguments,
+	})
+}
+func (debugger) AssembleGetLength(assembly_code string, start_address uint64, length uint32) bool {
+	return request[bool]("AssembleGetLength", map[string]string{
+		"assembly_code": assembly_code,
+		"start_address": strconv.FormatUint(start_address, 10),
+		"length":        strconv.FormatUint(uint64(length), 10),
+	})
+}
+func (debugger) Assemble(assembly_code string, start_address uint64, buffer_to_store_assembled_data uint64, buffer_size uint32) bool {
+	return request[bool]("Assemble", map[string]string{
+		"assembly_code":                  assembly_code,
+		"start_address":                  strconv.FormatUint(start_address, 10),
+		"buffer_to_store_assembled_data": strconv.FormatUint(uint64(buffer_to_store_assembled_data), 10),
+		"buffer_size":                    strconv.FormatUint(uint64(buffer_size), 10),
+	})
+}
+func (debugger) SetupPathForFileName(filename string, file_location string, buffer_len uint32, check_file_existence bool) bool {
+	return request[bool]("SetupPathForFileName", map[string]string{
+		"filename":             filename,
+		"file_location":        file_location,
+		"buffer_len":           strconv.FormatUint(uint64(buffer_len), 10),
+		"check_file_existence": strconv.FormatBool(check_file_existence),
+	})
+}
+func (debugger) SteppingInstrumentationStepIn() bool {
+	return request[bool]("SteppingInstrumentationStepIn", nil)
+}
+func (debugger) SteppingRegularStepIn() bool {
+	return request[bool]("SteppingRegularStepIn", nil)
+}
+func (debugger) SteppingStepOver() bool {
+	return request[bool]("SteppingStepOver", nil)
+}
+func (debugger) SteppingInstrumentationStepInForTracking() bool {
+	return request[bool]("SteppingInstrumentationStepInForTracking", nil)
+}
+func (debugger) SteppingStepOverForGu(last_instruction bool) bool {
+	return request[bool]("SteppingStepOverForGu", map[string]string{"last_instruction": strconv.FormatBool(last_instruction)})
+}
+func (debugger) GetLocalApic(local_apic PLAPIC_PAGE, is_using_x2apic bool) bool {
+	return request[bool]("GetLocalApic", map[string]string{
+		"local_apic":      string(stream.MarshalJSON(local_apic)),
+		"is_using_x2apic": strconv.FormatBool(is_using_x2apic),
+	})
+}
+func (debugger) GetIoApic(io_apic IO_APIC_ENTRY_PACKETS) bool {
+	return request[bool]("GetIoApic", map[string]string{"io_apic": string(stream.MarshalJSON(io_apic))})
+}
+func (debugger) GetIdtEntry(idt_packet INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS) bool {
+	return request[bool]("GetIdtEntry", map[string]string{"idt_packet": string(stream.MarshalJSON(idt_packet))})
+}
+func (debugger) HwdbgScriptRunScript(script string, instance_filepath_to_read string, hardware_script_file_path_to_save string, initial_bram_buffer_size uint32) bool {
+	return request[bool]("HwdbgScriptRunScript", map[string]string{
+		"script":                            script,
+		"instance_filepath_to_read":         instance_filepath_to_read,
+		"hardware_script_file_path_to_save": hardware_script_file_path_to_save,
+		"initial_bram_buffer_size":          strconv.FormatUint(uint64(initial_bram_buffer_size), 10),
+	})
+}
+func (debugger) ScriptEngineWrapperTestParserForHwdbg(Expr string) {
+	request[void]("ScriptEngineWrapperTestParserForHwdbg", map[string]string{"Expr": Expr})
+}
+func (debugger) EnableTransparentMode(ProcessId uint32, ProcessName string, IsProcessId bool) bool {
+	return request[bool]("EnableTransparentMode", map[string]string{
+		"ProcessId":   strconv.FormatUint(uint64(ProcessId), 10),
+		"ProcessName": ProcessName,
+		"IsProcessId": strconv.FormatBool(IsProcessId),
+	})
+}
+func (debugger) DisableTransparentMode() bool {
+	return request[bool]("DisableTransparentMode", nil)
+}
Index: hyperdbg/libhyperdbg/code/export/bindings/python/sdk.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/bindings/python/sdk.py b/hyperdbg/libhyperdbg/code/export/bindings/python/sdk.py
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/bindings/python/sdk.py	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,223 @@
+import sys
+import requests
+import json
+
+from mcp.server.fastmcp import FastMCP
+
+DEFAULT_HyperDBG_SERVER = "http://127.0.0.1:8888/"
+hyperdbg_server_url = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HyperDBG_SERVER
+
+mcp = FastMCP("hyperdbg-mcp")
+
+def safe_get(endpoint: str, params: dict = None):
+    """
+    Perform a GET request with optional query parameters.
+    Returns parsed JSON if possible, otherwise text content
+    """
+    if params is None:
+        params = {}
+
+    url = f"{hyperdbg_server_url}{endpoint}"
+
+    try:
+        response = requests.get(url, params=params, timeout=15)
+        response.encoding = 'utf-8'
+        if response.ok:
+            # Try to parse as JSON first
+            try:
+                return response.json()
+            except ValueError:
+                return response.text.strip()
+        else:
+            return f"Error {response.status_code}: {response.text.strip()}"
+    except Exception as e:
+        return f"Request failed: {str(e)}"
+
+def safe_post(endpoint: str, data: dict | str):
+    """
+    Perform a POST request with data.
+    Returns parsed JSON if possible, otherwise text content
+    """
+    try:
+        url = f"{hyperdbg_server_url}{endpoint}"
+        if isinstance(data, dict):
+            response = requests.post(url, data=data, timeout=5)
+        else:
+            response = requests.post(url, data=data.encode("utf-8"), timeout=5)
+        
+        response.encoding = 'utf-8'
+        
+        if response.ok:
+            # Try to parse as JSON first
+            try:
+                return response.json()
+            except ValueError:
+                return response.text.strip()
+        else:
+            return f"Error {response.status_code}: {response.text.strip()}"
+    except Exception as e:
+        return f"Request failed: {str(e)}"
+@mcp.tool()
+def VmxSupportDetection()
+
+@mcp.tool()
+def CpuReadVendorString()
+
+@mcp.tool()
+def HyperDbgLoadVmmModule()
+
+@mcp.tool()
+def HyperDbgUnloadVmm()
+
+@mcp.tool()
+def HyperDbgInstallVmmDriver()
+
+@mcp.tool()
+def HyperDbgUninstallVmmDriver()
+
+@mcp.tool()
+def HyperDbgStopVmmDriver()
+
+@mcp.tool()
+def HyperDbgInterpreter()
+
+@mcp.tool()
+def HyperDbgTestCommandParser()
+
+@mcp.tool()
+def HyperDbgTestCommandParserShowTokens()
+
+@mcp.tool()
+def HyperDbgShowSignature()
+
+@mcp.tool()
+def SetTextMessageCallback()
+
+@mcp.tool()
+def SetTextMessageCallbackUsingSharedBuffer()
+
+@mcp.tool()
+def UnsetTextMessageCallback()
+
+@mcp.tool()
+def ScriptReadFileAndExecuteCommandline()
+
+@mcp.tool()
+def ContinuePreviousCommand()
+
+@mcp.tool()
+def CheckMultilineCommand()
+
+@mcp.tool()
+def ConnectLocalDebugger()
+
+@mcp.tool()
+def ConnectRemoteDebugger()
+
+@mcp.tool()
+def Continue()
+
+@mcp.tool()
+def Pause()
+
+@mcp.tool()
+def SetBreakPoint()
+
+@mcp.tool()
+def SetCustomDriverPath()
+
+@mcp.tool()
+def UseDefaultDriverPath()
+
+@mcp.tool()
+def HyperDbgReadMemory()
+
+@mcp.tool()
+def HyperDbgShowMemoryOrDisassemble()
+
+@mcp.tool()
+def HyperDbgReadAllRegisters()
+
+@mcp.tool()
+def HyperDbgReadTargetRegister()
+
+@mcp.tool()
+def HyperDbgWriteTargetRegister()
+
+@mcp.tool()
+def HyperDbgRegisterShowAll()
+
+@mcp.tool()
+def HyperDbgRegisterShowTargetRegister()
+
+@mcp.tool()
+def HyperDbgWriteMemory()
+
+@mcp.tool()
+def DebuggerGetKernelBase()
+
+@mcp.tool()
+def HyperDbgDebugRemoteDeviceUsingComPort()
+
+@mcp.tool()
+def HyperDbgDebugRemoteDeviceUsingNamedPipe()
+
+@mcp.tool()
+def HyperDbgDebugCloseRemoteDebugger()
+
+@mcp.tool()
+def HyperDbgDebugCurrentDeviceUsingComPort()
+
+@mcp.tool()
+def StartProcess()
+
+@mcp.tool()
+def StartProcessWithArgs()
+
+@mcp.tool()
+def HyperDbgAssembleGetLength()
+
+@mcp.tool()
+def HyperDbgAssemble()
+
+@mcp.tool()
+def SetupPathForFileName()
+
+@mcp.tool()
+def SteppingInstrumentationStepIn()
+
+@mcp.tool()
+def SteppingRegularStepIn()
+
+@mcp.tool()
+def SteppingStepOver()
+
+@mcp.tool()
+def SteppingInstrumentationStepInForTracking()
+
+@mcp.tool()
+def SteppingStepOverForGu()
+
+@mcp.tool()
+def HyperDbgGetLocalApic()
+
+@mcp.tool()
+def HyperDbgGetIoApic()
+
+@mcp.tool()
+def HyperDbgGetIdtEntry()
+
+@mcp.tool()
+def HwdbgScriptRunScript()
+
+@mcp.tool()
+def ScriptEngineWrapperTestParserForHwdbg()
+
+@mcp.tool()
+def HyperDbgEnableTransparentMode()
+
+@mcp.tool()
+def HyperDbgDisableTransparentMode()
+
+if __name__ == "__main__":
+    mcp.run()
Index: hyperdbg/libhyperdbg/code/export/go.mod
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/go.mod b/hyperdbg/libhyperdbg/code/export/go.mod
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/go.mod	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,11 @@
+module mcp
+
+go 1.25rc1
+
+require github.com/ddkwork/golibrary v0.1.5-0.20250627073414-26b52a7347b5
+
+require (
+	github.com/google/go-cmp v0.7.0 // indirect
+	golang.org/x/mod v0.25.0 // indirect
+	golang.org/x/text v0.26.0 // indirect
+)
Index: hyperdbg/libhyperdbg/code/export/go.sum
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/go.sum b/hyperdbg/libhyperdbg/code/export/go.sum
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/go.sum	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,8 @@
+github.com/ddkwork/golibrary v0.1.5-0.20250627073414-26b52a7347b5 h1:CQut6rboQQ1W78hU90jJz3mBbR4+n7isOX/k6AvWlHo=
+github.com/ddkwork/golibrary v0.1.5-0.20250627073414-26b52a7347b5/go.mod h1:Mz9h57QxktABXdNL99/xoYmUnXoR10BpR7xYnePIibA=
+github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
+github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
+golang.org/x/mod v0.25.0 h1:n7a+ZbQKQA/Ysbyb0/6IbB1H/X41mKgbhfv7AfG/44w=
+golang.org/x/mod v0.25.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
+golang.org/x/text v0.26.0 h1:P42AVeLghgTYr4+xUnTRKDMqpar+PtX7KWuNQL21L8M=
+golang.org/x/text v0.26.0/go.mod h1:QK15LZJUUQVJxhz7wXgxSy/CJaTFjd0G+YLonydOVQA=
Index: hyperdbg/libhyperdbg/code/export/mcp.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/mcp.cpp b/hyperdbg/libhyperdbg/code/export/mcp.cpp
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/mcp.cpp	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,1661 @@
+//#define WINSOCK_DEPRECATED_NO_WARNINGS
+//#define WIN32_LEAN_AND_MEAN
+
+#include <Windows.h>
+#include "pch.h"
+#include <iomanip>  // For std::setw and std::setfill
+
+// Socket includes - after Windows.h
+#include <winsock2.h>
+#include <ws2tcpip.h>
+
+// Standard library includes
+#include <string>
+#include <vector>
+#include <unordered_map>
+#include <sstream>
+#include <mutex>
+#include <thread>
+#include <algorithm>
+#include <memory>
+#include <fstream>
+
+#pragma comment(lib, "ws2_32.lib")
+
+#define PLUGIN_NAME "hyperdbg http Server"
+#define PLUGIN_VERSION 1
+
+// Default settings
+#define port 8888
+#define MAX_REQUEST_SIZE 8192
+
+// Global variables
+int g_pluginHandle;
+HANDLE g_httpServerThread = NULL;
+bool g_httpServerRunning = false;
+int g_httpPort = port;
+std::mutex g_httpMutex;
+SOCKET g_serverSocket = INVALID_SOCKET;
+
+// Forward declarations
+bool startHttpServer();
+
+void stopHttpServer();
+
+DWORD WINAPI HttpServerThread(LPVOID lpParam);
+
+std::string readHttpRequest(SOCKET clientSocket);
+
+void
+sendHttpResponse(SOCKET clientSocket, int statusCode, const std::string &contentType, const std::string &responseBody);
+
+void parseHttpRequest(const std::string &request, std::string &method, std::string &path, std::string &query,
+                      std::string &body);
+
+std::unordered_map<std::string, std::string> parseQueryParams(const std::string &query);
+
+std::string urlDecode(const std::string &str);
+
+// Command callback declarations
+bool cbEnableHttpServer(int argc, char *argv[]);
+
+bool cbSetHttpPort(int argc, char *argv[]);
+
+void registerCommands();
+
+
+// Initialize the plugin
+bool pluginInit() {
+//    initStruct->pluginVersion = PLUGIN_VERSION;
+//    initStruct->sdkVersion = PLUG_SDKVERSION;
+//    strncpy_s(initStruct->pluginName, PLUGIN_NAME, _TRUNCATE);
+//    g_pluginHandle = initStruct->pluginHandle;
+
+    printf("hyperdbg http Server  starting...");
+
+    // Register commands
+    registerCommands();
+
+    // Start the HTTP server
+    if (startHttpServer()) {
+        printf("hyperdbg http Server started on port %d\n", g_httpPort);
+    } else {
+        printf("Failed to start HTTP server!");
+    }
+
+    printf("hyperdbg http Server plugin loaded!");
+    return true;
+}
+
+// Stop the plugin
+void pluginStop() {
+    printf("Stopping hyperdbg http Server...");
+    stopHttpServer();
+    printf("hyperdbg http Server stopped.");
+}
+
+// Plugin setup
+bool pluginSetup() {
+    return true;
+}
+
+// Plugin exports
+bool pluginit() { return pluginInit(); }
+
+void plugstop() { pluginStop(); }
+
+void plugsetup() { pluginSetup(); }
+
+//=============================================================================
+// HTTP Server Implementation
+//=============================================================================
+
+// Start the HTTP server
+bool startHttpServer() {
+    std::lock_guard<std::mutex> lock(g_httpMutex);
+
+    // Stop existing server if running
+    if (g_httpServerRunning) {
+        stopHttpServer();
+    }
+
+    // Create and start the server thread
+    g_httpServerThread = CreateThread(NULL, 0, HttpServerThread, NULL, 0, NULL);
+    if (g_httpServerThread == NULL) {
+        printf("Failed to create HTTP server thread");
+        return false;
+    }
+
+    g_httpServerRunning = true;
+    return true;
+}
+
+// Stop the HTTP server
+void stopHttpServer() {
+    std::lock_guard<std::mutex> lock(g_httpMutex);
+
+    if (g_httpServerRunning) {
+        g_httpServerRunning = false;
+
+        // Close the server socket to unblock any accept calls
+        if (g_serverSocket != INVALID_SOCKET) {
+            closesocket(g_serverSocket);
+            g_serverSocket = INVALID_SOCKET;
+        }
+
+        // Wait for the thread to exit
+        if (g_httpServerThread != NULL) {
+            WaitForSingleObject(g_httpServerThread, 1000);
+            CloseHandle(g_httpServerThread);
+            g_httpServerThread = NULL;
+        }
+    }
+}
+
+// URL decode function
+std::string urlDecode(const std::string &str) {
+    std::string decoded;
+    for (size_t i = 0; i < str.length(); ++i) {
+        if (str[i] == '%' && i + 2 < str.length()) {
+            int value;
+            std::istringstream is(str.substr(i + 1, 2));
+            if (is >> std::hex >> value) {
+                decoded += static_cast<char>(value);
+                i += 2;
+            } else {
+                decoded += str[i];
+            }
+        } else if (str[i] == '+') {
+            decoded += ' ';
+        } else {
+            decoded += str[i];
+        }
+    }
+    return decoded;
+}
+
+// HTTP server thread function using standard Winsock
+DWORD WINAPI HttpServerThread(LPVOID lpParam) {
+    WSADATA wsaData;
+    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
+    if (result != 0) {
+        printf("WSAStartup failed with error: %d\n", result);
+        return 1;
+    }
+
+    // Create a socket for the server
+    g_serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (g_serverSocket == INVALID_SOCKET) {
+        printf("Failed to create socket, error: %d\n", WSAGetLastError());
+        WSACleanup();
+        return 1;
+    }
+
+    // Setup the server address structure
+    sockaddr_in serverAddr;
+    serverAddr.sin_family = AF_INET;
+    serverAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); // localhost only
+    serverAddr.sin_port = htons((u_short) g_httpPort);
+
+    // Bind the socket
+    if (::bind(g_serverSocket, (sockaddr *) &serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
+        printf("Bind failed with error: %d\n", WSAGetLastError());
+        closesocket(g_serverSocket);
+        WSACleanup();
+        return 1;
+    }
+
+    // Listen for incoming connections
+    if (listen(g_serverSocket, SOMAXCONN) == SOCKET_ERROR) {
+        printf("Listen failed with error: %d\n", WSAGetLastError());
+        closesocket(g_serverSocket);
+        WSACleanup();
+        return 1;
+    }
+
+    printf("HTTP server started at http://localhost:%d/\n", g_httpPort);
+
+    // Set socket to non-blocking mode
+    u_long mode = 1;
+    ioctlsocket(g_serverSocket, FIONBIO, &mode);
+
+    // Main server loop
+    while (g_httpServerRunning) {
+        // Accept a client connection
+        sockaddr_in clientAddr;
+        int clientAddrSize = sizeof(clientAddr);
+        SOCKET clientSocket = accept(g_serverSocket, (sockaddr *) &clientAddr, &clientAddrSize);
+
+        if (clientSocket == INVALID_SOCKET) {
+            // Check if we need to exit
+            if (!g_httpServerRunning) {
+                break;
+            }
+
+            // Non-blocking socket may return WOULD_BLOCK when no connections are pending
+            if (WSAGetLastError() != WSAEWOULDBLOCK) {
+                printf("Accept failed with error: %d\n", WSAGetLastError());
+            }
+
+            Sleep(100); // Avoid tight loop
+            continue;
+        }
+
+        // Read the HTTP request
+        std::string requestData = readHttpRequest(clientSocket);
+
+        if (!requestData.empty()) {
+            // Parse the HTTP request
+            std::string method, path, query, body;
+            parseHttpRequest(requestData, method, path, query, body);
+
+            printf("HTTP Request: %s %s\n", method.c_str(), path.c_str());
+
+            // Parse query parameters
+            std::unordered_map<std::string, std::string> queryParams = parseQueryParams(query);
+
+            //findasm "mov dword ptr ds:[edi+0x5E8],eax", 0x401000
+//            HyperDbgInterpreter("findasm \"mov dword ptr ds:[edi+0x5E8],eax\", 0x401000");
+            //DbgGetBpList();
+
+            // Handle different endpoints
+            try {
+                // Unified command execution endpoint
+                if (path == "/ExecCommand") {
+                    std::string cmd = queryParams["command"];
+                    if (cmd.empty() && !body.empty()) {
+                        cmd = body;
+                    }
+
+                    if (cmd.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing command parameter");
+                        continue;
+                    }
+
+                    // Generate unique temporary log file
+                    char tempPath[MAX_PATH];
+                    GetTempPathA(MAX_PATH, tempPath);
+                    std::string logFile =
+                            std::string(tempPath) + "hyperdbg_cmd_" + std::to_string(GetTickCount()) + ".log";
+
+                    // Start log redirection
+                    std::string redirectCmd = "LogRedirect \"" + logFile + "\"";
+                    HyperDbgInterpreter(&*redirectCmd.begin());
+
+                    // Small delay to ensure redirection is active
+                    Sleep(50);
+
+                    // Clear any existing content in the log
+                    HyperDbgInterpreter("LogClear");
+
+                    // Small delay after clearing
+                    Sleep(50);
+
+                    // Execute the actual command
+                    bool success = HyperDbgInterpreter(&*cmd.begin());
+
+                    // Wait for command to complete and output to be written
+                    Sleep(200);
+
+                    // Stop log redirection
+                    HyperDbgInterpreter("LogRedirectStop");
+
+                    // Wait a bit more for file operations to complete
+                    Sleep(100);
+
+                    // Read the captured output with retry mechanism
+                    std::string output;
+                    int retryCount = 0;
+                    const int maxRetries = 5;
+
+                    while (retryCount < maxRetries) {
+                        std::ifstream file(logFile, std::ios::binary);
+                        if (file.is_open()) {
+                            // Get file size
+                            file.seekg(0, std::ios::end);
+                            std::streamsize fileSize = file.tellg();
+                            file.seekg(0, std::ios::beg);
+
+                            if (fileSize > 0) {
+                                // Read the entire file
+                                std::stringstream buffer;
+                                buffer << file.rdbuf();
+                                output = buffer.str();
+                                file.close();
+                                break;
+                            } else {
+                                file.close();
+                                // File exists but is empty, wait and retry
+                                Sleep(100);
+                                retryCount++;
+                            }
+                        } else {
+                            // File doesn't exist yet, wait and retry
+                            Sleep(100);
+                            retryCount++;
+                        }
+                    }
+
+                    // Clean up temporary file
+                    DeleteFileA(logFile.c_str());
+
+                    // Process the captured output
+                    if (!output.empty()) {
+                        // Filter out log redirection messages
+                        size_t pos = 0;
+                        while ((pos = output.find("Log will be redirected to", pos)) != std::string::npos) {
+                            size_t endPos = output.find('\n', pos);
+                            if (endPos != std::string::npos) {
+                                output.erase(pos, endPos - pos + 1);
+                            } else {
+                                output.erase(pos);
+                                break;
+                            }
+                        }
+
+                        // Remove "Log redirection stopped" messages
+                        pos = 0;
+                        while ((pos = output.find("Log redirection stopped", pos)) != std::string::npos) {
+                            size_t endPos = output.find('\n', pos);
+                            if (endPos != std::string::npos) {
+                                output.erase(pos, endPos - pos + 1);
+                            } else {
+                                output.erase(pos);
+                                break;
+                            }
+                        }
+
+                        // Remove "Log cleared" messages
+                        pos = 0;
+                        while ((pos = output.find("Log cleared", pos)) != std::string::npos) {
+                            size_t endPos = output.find('\n', pos);
+                            if (endPos != std::string::npos) {
+                                output.erase(pos, endPos - pos + 1);
+                            } else {
+                                output.erase(pos);
+                                break;
+                            }
+                        }
+
+                        // Trim whitespace and empty lines
+                        output.erase(0, output.find_first_not_of(" \t\n\r"));
+                        output.erase(output.find_last_not_of(" \t\n\r") + 1);
+                    }
+
+                    // Prepare response
+                    std::string response;
+                    if (success) {
+                        if (!output.empty()) {
+                            response = output;
+                        } else {
+                            response = "Command executed successfully (no output captured)";
+                        }
+                    } else {
+                        if (!output.empty()) {
+                            response = "Command failed:\n" + output;
+                        } else {
+                            response = "Command execution failed";
+                        }
+                    }
+
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain", response);
+                } else if (path == "/VmxSupportDetection") {
+                    auto b = VmxSupportDetection();
+                    std::string response = b ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/CpuReadVendorString") {
+//#include "commands.h"
+//                    std::string VendorString = InstructionSet::Vendor();//todo
+//                    std::string vendorString = CpuReadVendorString();
+//                    sendHttpResponse(clientSocket, 200, "text/plain", vendorString);
+                } else if (path == "/LoadVmmModule") {
+                    bool success = HyperDbgLoadVmmModule();
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/UnloadVmm") {
+                    bool success = HyperDbgUnloadVmm();
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/InstallVmmDriver") {
+                    bool success = HyperDbgInstallVmmDriver();
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/UninstallVmmDriver") {
+                    bool success = HyperDbgUninstallVmmDriver();
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/StopVmmDriver") {
+                    bool success = HyperDbgStopVmmDriver();
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/Interpreter") {
+                    std::string command = queryParams["command"];
+                    if (command.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing command parameter");
+                        continue;
+                    }
+
+                    bool success = HyperDbgInterpreter(&*command.begin());
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/TestCommandParser") {
+                    std::string command = queryParams["command"];
+                    if (command.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing command parameter");
+                        continue;
+                    }
+
+                    int number_of_tokens = std::stoi(queryParams["number_of_tokens"]);
+                    std::string tokens_list = queryParams["tokens_list"];
+                    int failed_token_num = std::stoi(queryParams["failed_token_num"]);
+                    int failed_token_position = std::stoi(queryParams["failed_token_position"]);
+
+//                    bool success = HyperDbgTestCommandParser(command.c_str(), number_of_tokens, tokens_list.c_str(), failed_token_num, failed_token_position);
+//                    std::string response = success ? "true" : "false";
+//                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/TestCommandParserShowTokens") {
+                    std::string command = queryParams["command"];
+                    if (command.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing command parameter");
+                        continue;
+                    }
+
+                    HyperDbgTestCommandParserShowTokens(&*command.begin());
+                    sendHttpResponse(clientSocket, 200, "text/plain", "OK");
+                } else if (path ==
+                           "/SetTextMessageCallbackUsingSharedBuffer") {//todo remove this use execute command instead stdout and stderr
+//                    std::string handler = queryParams["handler"];
+//                    if (handler.empty()) {
+//                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing handler parameter");
+//                        continue;
+//                    }
+//
+//                    auto success = SetTextMessageCallbackUsingSharedBuffer(handler.c_str());
+//                    std::string response = success ? "true" : "false";
+//                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/ScriptReadFileAndExecuteCommandline") {
+                    int argc = std::stoi(queryParams["argc"]);
+                    std::string argv = queryParams["argv"];
+                    if (argv.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing argv parameter");
+                        continue;
+                    }
+
+//                    auto success = ScriptReadFileAndExecuteCommandline(argc, argv.c_str());
+                    auto success = false;
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/ContinuePreviousCommand") {
+                    bool success = ContinuePreviousCommand();
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/CheckMultilineCommand") {
+                    std::string current_command = queryParams["current_command"];
+                    auto reset = std::stoi(queryParams["reset"]);
+                    auto success = CheckMultilineCommand(&*current_command.begin(), reset);
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/ConnectRemoteDebugger") {
+                    std::string ip = queryParams["ip"];
+                    std::string port1 = queryParams["port"];
+                    if (ip.empty() || port1.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing ip or port parameter");
+                        continue;
+                    }
+
+                    auto success = ConnectRemoteDebugger(ip.c_str(), port1.c_str());
+//                    auto success = ConnectRemoteDebugger(ip.c_str(), std::stoi(port));
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/ReadMemory") {
+                    std::string target_address = queryParams["target_address"];
+                    std::string memory_type = queryParams["memory_type"];
+                    std::string reading_Type = queryParams["reading_Type"];
+                    std::string pid = queryParams["pid"];
+                    std::string size = queryParams["size"];
+                    std::string get_address_mode = queryParams["get_address_mode"];
+                    std::string address_mode = queryParams["address_mode"];
+                    std::string target_buffer_to_store = queryParams["target_buffer_to_store"];
+                    std::string return_length = queryParams["return_length"];
+
+                    if (target_address.empty() || memory_type.empty() || reading_Type.empty() || pid.empty() ||
+                        size.empty() || get_address_mode.empty() || address_mode.empty() ||
+                        target_buffer_to_store.empty() || return_length.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing parameter");
+                        continue;
+                    }
+
+//                    unsigned int target_address_int = std::stoll(target_address, nullptr, 16);
+//                    unsigned int size_int = std::stoll(size, nullptr, 10);
+                    unsigned int *target_buffer = (unsigned int *) target_buffer_to_store.c_str();
+                    unsigned int *return_length_int = (unsigned int *) return_length.c_str();
+
+                    //todo gen stringer
+//                    auto success = HyperDbgReadMemory(
+//                            target_address_int,
+//                            DEBUGGER_READ_PHYSICAL_ADDRESS,
+//                            READ_FROM_KERNEL,
+//                            std::stoi(pid),
+//                            size_int,
+//                            true,
+//                            DEBUGGER_READ_ADDRESS_MODE_32_BIT,
+//                            target_buffer,
+//                            return_length_int);
+                    auto success = false;
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+                } else if (path == "/WriteMemory") {
+                    std::string target_address = queryParams["target_address"];
+                    std::string memory_type = queryParams["memory_type"];
+                    std::string writing_Type = queryParams["writing_Type"];
+                    std::string pid = queryParams["pid"];
+                    std::string size = queryParams["size"];
+                    std::string get_address_mode = queryParams["get_address_mode"];
+                    std::string address_mode = queryParams["address_mode"];
+                    std::string source_buffer_to_write = queryParams["source_buffer_to_write"];
+                    std::string return_length = queryParams["return_length"];
+
+                    if (target_address.empty() || memory_type.empty() || writing_Type.empty() || pid.empty() ||
+                        size.empty() || get_address_mode.empty() || address_mode.empty() ||
+                        source_buffer_to_write.empty() || return_length.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing parameter");
+                        continue;
+                    }
+
+                    auto target_address_int = std::stoll(target_address, nullptr, 16);
+                    auto size_int = std::stoll(size, nullptr, 10);
+                    auto source_buffer = (unsigned int *) source_buffer_to_write.c_str();
+                    auto return_length_int = (unsigned int *) return_length.c_str();
+
+//                    auto success = HyperDbgWriteMemory(target_address_int, memory_type.c_str(), writing_Type.c_str(), std::stoi(pid), size_int, get_address_mode.c_str(), address_mode.c_str(), source_buffer, return_length_int);
+                    auto success = false;
+                    std::string response = success ? "true" : "false";
+                    sendHttpResponse(clientSocket, 200, "text/plain", response);
+
+                }
+
+
+
+//                else if (path == "/IsDebugActive") {
+//                    bool active = DbgIsRunning();
+//                    sendHttpResponse(clientSocket, 200, "text/plain", active ? "true" : "false");
+//                } else if (path == "/Is_Debugging") {
+//                    bool isDebugging = DbgIsDebugging();
+//                    sendHttpResponse(clientSocket, 200, "text/plain", isDebugging ? "true" : "false");
+//                }
+
+/*
+                    // =============================================================================
+                    // REGISTER API ENDPOINTS
+                    // =============================================================================
+                else if (path == "/Register/Get") {
+                    std::string regName = queryParams["register"];
+                    if (regName.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing register parameter");
+                        continue;
+                    }
+
+                    // Convert register name to enum (simplified mapping)
+                    Script::Register::RegisterEnum reg;
+                    if (regName == "EAX" || regName == "eax") reg = Script::Register::EAX;
+                    else if (regName == "EBX" || regName == "ebx") reg = Script::Register::EBX;
+                    else if (regName == "ECX" || regName == "ecx") reg = Script::Register::ECX;
+                    else if (regName == "EDX" || regName == "edx") reg = Script::Register::EDX;
+                    else if (regName == "ESI" || regName == "esi") reg = Script::Register::ESI;
+                    else if (regName == "EDI" || regName == "edi") reg = Script::Register::EDI;
+                    else if (regName == "EBP" || regName == "ebp") reg = Script::Register::EBP;
+                    else if (regName == "ESP" || regName == "esp") reg = Script::Register::ESP;
+                    else if (regName == "EIP" || regName == "eip") reg = Script::Register::EIP;
+#ifdef _WIN64
+                    else if (regName == "RAX" || regName == "rax") reg = Script::Register::RAX;
+                    else if (regName == "RBX" || regName == "rbx") reg = Script::Register::RBX;
+                    else if (regName == "RCX" || regName == "rcx") reg = Script::Register::RCX;
+                    else if (regName == "RDX" || regName == "rdx") reg = Script::Register::RDX;
+                    else if (regName == "RSI" || regName == "rsi") reg = Script::Register::RSI;
+                    else if (regName == "RDI" || regName == "rdi") reg = Script::Register::RDI;
+                    else if (regName == "RBP" || regName == "rbp") reg = Script::Register::RBP;
+                    else if (regName == "RSP" || regName == "rsp") reg = Script::Register::RSP;
+                    else if (regName == "RIP" || regName == "rip") reg = Script::Register::RIP;
+                    else if (regName == "R8" || regName == "r8") reg = Script::Register::R8;
+                    else if (regName == "R9" || regName == "r9") reg = Script::Register::R9;
+                    else if (regName == "R10" || regName == "r10") reg = Script::Register::R10;
+                    else if (regName == "R11" || regName == "r11") reg = Script::Register::R11;
+                    else if (regName == "R12" || regName == "r12") reg = Script::Register::R12;
+                    else if (regName == "R13" || regName == "r13") reg = Script::Register::R13;
+                    else if (regName == "R14" || regName == "r14") reg = Script::Register::R14;
+                    else if (regName == "R15" || regName == "r15") reg = Script::Register::R15;
+#endif
+                    else {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Unknown register");
+                        continue;
+                    }
+
+                    unsigned  int value = Script::Register::Get(reg);
+                    std::stringstream ss;
+                    ss << "0x" << std::hex << value;
+                    sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                } else if (path == "/Register/Set") {
+                    std::string regName = queryParams["register"];
+                    std::string valueStr = queryParams["value"];
+                    if (regName.empty() || valueStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing register or value parameter");
+                        continue;
+                    }
+
+                    // Convert register name to enum (same mapping as above)
+                    Script::Register::RegisterEnum reg;
+                    if (regName == "EAX" || regName == "eax") reg = Script::Register::EAX;
+                    else if (regName == "EBX" || regName == "ebx") reg = Script::Register::EBX;
+                    else if (regName == "ECX" || regName == "ecx") reg = Script::Register::ECX;
+                    else if (regName == "EDX" || regName == "edx") reg = Script::Register::EDX;
+                    else if (regName == "ESI" || regName == "esi") reg = Script::Register::ESI;
+                    else if (regName == "EDI" || regName == "edi") reg = Script::Register::EDI;
+                    else if (regName == "EBP" || regName == "ebp") reg = Script::Register::EBP;
+                    else if (regName == "ESP" || regName == "esp") reg = Script::Register::ESP;
+                    else if (regName == "EIP" || regName == "eip") reg = Script::Register::EIP;
+#ifdef _WIN64
+                    else if (regName == "RAX" || regName == "rax") reg = Script::Register::RAX;
+                    else if (regName == "RBX" || regName == "rbx") reg = Script::Register::RBX;
+                    else if (regName == "RCX" || regName == "rcx") reg = Script::Register::RCX;
+                    else if (regName == "RDX" || regName == "rdx") reg = Script::Register::RDX;
+                    else if (regName == "RSI" || regName == "rsi") reg = Script::Register::RSI;
+                    else if (regName == "RDI" || regName == "rdi") reg = Script::Register::RDI;
+                    else if (regName == "RBP" || regName == "rbp") reg = Script::Register::RBP;
+                    else if (regName == "RSP" || regName == "rsp") reg = Script::Register::RSP;
+                    else if (regName == "RIP" || regName == "rip") reg = Script::Register::RIP;
+                    else if (regName == "R8" || regName == "r8") reg = Script::Register::R8;
+                    else if (regName == "R9" || regName == "r9") reg = Script::Register::R9;
+                    else if (regName == "R10" || regName == "r10") reg = Script::Register::R10;
+                    else if (regName == "R11" || regName == "r11") reg = Script::Register::R11;
+                    else if (regName == "R12" || regName == "r12") reg = Script::Register::R12;
+                    else if (regName == "R13" || regName == "r13") reg = Script::Register::R13;
+                    else if (regName == "R14" || regName == "r14") reg = Script::Register::R14;
+                    else if (regName == "R15" || regName == "r15") reg = Script::Register::R15;
+#endif
+                    else {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Unknown register");
+                        continue;
+                    }
+
+                    unsigned  int value = 0;
+                    try {
+                        if (valueStr.substr(0, 2) == "0x") {
+                            value = std::stoull(valueStr.substr(2), nullptr, 16);
+                        } else {
+                            value = std::stoull(valueStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid value format");
+                        continue;
+                    }
+
+                    bool success = Script::Register::Set(reg, value);
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain",
+                                     success ? "Register set successfully" : "Failed to set register");
+                }
+
+                    // =============================================================================
+                    // MEMORY API ENDPOINTS (Enhanced)
+                    // =============================================================================
+                else if (path == "/Memory/Read") {
+                    std::string addrStr = queryParams["addr"];
+                    std::string sizeStr = queryParams["size"];
+
+                    if (addrStr.empty() || sizeStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address or size");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    unsigned  int size = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                        size = std::stoull(sizeStr, nullptr, 10);
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address or size format");
+                        continue;
+                    }
+
+                    if (size > 1024 * 1024) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Size too large");
+                        continue;
+                    }
+
+                    std::vector<unsigned char> buffer(size);
+                    unsigned  int sizeRead = 0;
+
+                    if (!Script::Memory::Read(addr, buffer.data(), size, &sizeRead)) {
+                        sendHttpResponse(clientSocket, 500, "text/plain", "Failed to read memory");
+                        continue;
+                    }
+
+                    std::stringstream ss;
+                    for (unsigned  int i = 0; i < sizeRead; i++) {
+                        ss << std::setw(2) << std::setfill('0') << std::hex << (int) buffer[i];
+                    }
+
+                    sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                } else if (path == "/Memory/Write") {
+                    std::string addrStr = queryParams["addr"];
+                    std::string dataStr = !body.empty() ? body : queryParams["data"];
+
+                    if (addrStr.empty() || dataStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address or data");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    std::vector<unsigned char> buffer;
+                    for (size_t i = 0; i < dataStr.length(); i += 2) {
+                        if (i + 1 >= dataStr.length()) break;
+                        std::string byteString = dataStr.substr(i, 2);
+                        try {
+                            unsigned char byte = (unsigned char) std::stoi(byteString, nullptr, 16);
+                            buffer.push_back(byte);
+                        } catch (const std::exception &e) {
+                            sendHttpResponse(clientSocket, 400, "text/plain", "Invalid data format");
+                            continue;
+                        }
+                    }
+
+                    unsigned  int sizeWritten = 0;
+                    bool success = Script::Memory::Write(addr, buffer.data(), buffer.size(), &sizeWritten);
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain",
+                                     success ? "Memory written successfully" : "Failed to write memory");
+                } else if (path == "/Memory/IsValidPtr") {
+                    std::string addrStr = queryParams["addr"];
+                    if (addrStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    bool isValid = Script::Memory::IsValidPtr(addr);
+                    sendHttpResponse(clientSocket, 200, "text/plain", isValid ? "true" : "false");
+                } else if (path == "/Memory/GetProtect") {
+                    std::string addrStr = queryParams["addr"];
+                    if (addrStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    unsigned int protect = Script::Memory::GetProtect(addr);
+                    std::stringstream ss;
+                    ss << "0x" << std::hex << protect;
+                    sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                }
+
+                    // =============================================================================
+                    // DEBUG API ENDPOINTS
+                    // =============================================================================
+                else if (path == "/Debug/Run") {
+                    Script::Debug::Run();
+                    sendHttpResponse(clientSocket, 200, "text/plain", "Debug run executed");
+                } else if (path == "/Debug/Pause") {
+                    Script::Debug::Pause();
+                    sendHttpResponse(clientSocket, 200, "text/plain", "Debug pause executed");
+                } else if (path == "/Debug/Stop") {
+                    Script::Debug::Stop();
+                    sendHttpResponse(clientSocket, 200, "text/plain", "Debug stop executed");
+                } else if (path == "/Debug/StepIn") {
+                    Script::Debug::StepIn();
+                    sendHttpResponse(clientSocket, 200, "text/plain", "Step in executed");
+                } else if (path == "/Debug/StepOver") {
+                    Script::Debug::StepOver();
+                    sendHttpResponse(clientSocket, 200, "text/plain", "Step over executed");
+                } else if (path == "/Debug/StepOut") {
+                    Script::Debug::StepOut();
+                    sendHttpResponse(clientSocket, 200, "text/plain", "Step out executed");
+                } else if (path == "/Debug/SetBreakpoint") {
+                    std::string addrStr = queryParams["addr"];
+                    if (addrStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    bool success = Script::Debug::SetBreakpoint(addr);
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain",
+                                     success ? "Breakpoint set successfully" : "Failed to set breakpoint");
+                } else if (path == "/Debug/DeleteBreakpoint") {
+                    std::string addrStr = queryParams["addr"];
+                    if (addrStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    bool success = Script::Debug::DeleteBreakpoint(addr);
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain",
+                                     success ? "Breakpoint deleted successfully" : "Failed to delete breakpoint");
+                }
+
+                    // =============================================================================
+                    // ASSEMBLER API ENDPOINTS
+                    // =============================================================================
+                else if (path == "/Assembler/Assemble") {
+                    std::string addrStr = queryParams["addr"];
+                    std::string instruction = queryParams["instruction"];
+                    if (instruction.empty() && !body.empty()) {
+                        instruction = body;
+                    }
+
+                    if (addrStr.empty() || instruction.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address or instruction parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    unsigned char dest[16];
+                    int size = 16;
+                    bool success = Script::Assembler::Assemble(addr, dest, &size, instruction.c_str());
+
+                    if (success) {
+                        std::stringstream ss;
+                        ss << "{\"success\":true,\"size\":" << size << ",\"bytes\":\"";
+                        for (int i = 0; i < size; i++) {
+                            ss << std::setw(2) << std::setfill('0') << std::hex << (int) dest[i];
+                        }
+                        ss << "\"}";
+                        sendHttpResponse(clientSocket, 200, "application/json", ss.str());
+                    } else {
+                        sendHttpResponse(clientSocket, 500, "text/plain", "Failed to assemble instruction");
+                    }
+                } else if (path == "/Assembler/AssembleMem") {
+                    std::string addrStr = queryParams["addr"];
+                    std::string instruction = queryParams["instruction"];
+                    if (instruction.empty() && !body.empty()) {
+                        instruction = body;
+                    }
+
+                    if (addrStr.empty() || instruction.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address or instruction parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    bool success = Script::Assembler::AssembleMem(addr, instruction.c_str());
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain",
+                                     success ? "Instruction assembled in memory successfully"
+                                             : "Failed to assemble instruction in memory");
+                }
+
+                    // =============================================================================
+                    // STACK API ENDPOINTS
+                    // =============================================================================
+                else if (path == "/Stack/Pop") {
+                    unsigned  int value = Script::Stack::Pop();
+                    std::stringstream ss;
+                    ss << "0x" << std::hex << value;
+                    sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                } else if (path == "/Stack/Push") {
+                    std::string valueStr = queryParams["value"];
+                    if (valueStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing value parameter");
+                        continue;
+                    }
+
+                    unsigned  int value = 0;
+                    try {
+                        if (valueStr.substr(0, 2) == "0x") {
+                            value = std::stoull(valueStr.substr(2), nullptr, 16);
+                        } else {
+                            value = std::stoull(valueStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid value format");
+                        continue;
+                    }
+
+                    unsigned  int prevTop = Script::Stack::Push(value);
+                    std::stringstream ss;
+                    ss << "0x" << std::hex << prevTop;
+                    sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                } else if (path == "/Stack/Peek") {
+                    std::string offsetStr = queryParams["offset"];
+                    int offset = 0;
+                    if (!offsetStr.empty()) {
+                        try {
+                            offset = std::stoi(offsetStr);
+                        } catch (const std::exception &e) {
+                            sendHttpResponse(clientSocket, 400, "text/plain", "Invalid offset format");
+                            continue;
+                        }
+                    }
+
+                    unsigned  int value = Script::Stack::Peek(offset);
+                    std::stringstream ss;
+                    ss << "0x" << std::hex << value;
+                    sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                } else if (path == "/Disasm/GetInstruction") {
+                    std::string addrStr = queryParams["addr"];
+                    if (addrStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    // Use the correct DISASM_INSTR structure
+                    DISASM_INSTR instr;
+                    DbgDisasmAt(addr, &instr);
+
+                    // Create JSON response with available instruction details
+                    std::stringstream ss;
+                    ss << "{";
+                    ss << "\"address\":\"0x" << std::hex << addr << "\",";
+                    ss << "\"instruction\":\"" << instr.instruction << "\",";
+                    ss << "\"size\":" << std::dec << instr.instr_size;
+                    ss << "}";
+
+                    sendHttpResponse(clientSocket, 200, "application/json", ss.str());
+                } else if (path == "/Disasm/GetInstructionRange") {
+                    std::string addrStr = queryParams["addr"];
+                    std::string countStr = queryParams["count"];
+
+                    if (addrStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    int count = 1;
+
+                    try {
+                        if (addrStr.substr(0, 2) == "0x") {
+                            addr = std::stoull(addrStr.substr(2), nullptr, 16);
+                        } else {
+                            addr = std::stoull(addrStr, nullptr, 16);
+                        }
+
+                        if (!countStr.empty()) {
+                            count = std::stoi(countStr);
+                        }
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address or count format");
+                        continue;
+                    }
+
+                    if (count <= 0 || count > 100) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Count must be between 1 and 100");
+                        continue;
+                    }
+
+                    // Get multiple instructions
+                    std::stringstream ss;
+                    ss << "[";
+
+                    unsigned  int currentAddr = addr;
+                    for (int i = 0; i < count; i++) {
+                        DISASM_INSTR instr;
+                        DbgDisasmAt(currentAddr, &instr);
+
+                        if (instr.instr_size > 0) {
+                            if (i > 0) ss << ",";
+
+                            ss << "{";
+                            ss << "\"address\":\"0x" << std::hex << currentAddr << "\",";
+                            ss << "\"instruction\":\"" << instr.instruction << "\",";
+                            ss << "\"size\":" << std::dec << instr.instr_size;
+                            ss << "}";
+
+                            currentAddr += instr.instr_size;
+                        } else {
+                            break;
+                        }
+                    }
+
+                    ss << "]";
+                    sendHttpResponse(clientSocket, 200, "application/json", ss.str());
+                }
+#ifdef _WIN64
+                else if (path == "/Disasm/GetInstructionAtRIP") {
+
+                    // Get current RIP and disassemble
+                    unsigned  int rip = Script::Register::Get(Script::Register::RIP);
+
+                    DISASM_INSTR instr;
+                    DbgDisasmAt(rip, &instr);
+
+                    // Create JSON response
+                    std::stringstream ss;
+                    ss << "{";
+                    ss << "\"rip\":\"0x" << std::hex << rip << "\",";
+                    ss << "\"instruction\":\"" << instr.instruction << "\",";
+                    ss << "\"size\":" << std::dec << instr.instr_size;
+                    ss << "}";
+
+                    sendHttpResponse(clientSocket, 200, "application/json", ss.str());
+
+                } else if (path == "/Disasm/StepInWithDisasm") {
+                    // Step in first
+                    Script::Debug::StepIn();
+
+                    // Then get current instruction
+                    unsigned  int rip = Script::Register::Get(Script::Register::RIP);
+
+                    DISASM_INSTR instr;
+                    DbgDisasmAt(rip, &instr);
+
+                    // Create JSON response
+                    std::stringstream ss;
+                    ss << "{";
+                    ss << "\"step_result\":\"Step in executed\",";
+                    ss << "\"rip\":\"0x" << std::hex << rip << "\",";
+                    ss << "\"instruction\":\"" << instr.instruction << "\",";
+                    ss << "\"size\":" << std::dec << instr.instr_size;
+                    ss << "}";
+
+                    sendHttpResponse(clientSocket, 200, "application/json", ss.str());
+                }
+#endif
+                    // =============================================================================
+                    // FLAG API ENDPOINTS
+                    // =============================================================================
+                else if (path == "/Flag/Get") {
+                    std::string flagName = queryParams["flag"];
+                    if (flagName.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing flag parameter");
+                        continue;
+                    }
+
+                    bool value = false;
+                    if (flagName == "ZF" || flagName == "zf") value = Script::Flag::GetZF();
+                    else if (flagName == "OF" || flagName == "of") value = Script::Flag::GetOF();
+                    else if (flagName == "CF" || flagName == "cf") value = Script::Flag::GetCF();
+                    else if (flagName == "PF" || flagName == "pf") value = Script::Flag::GetPF();
+                    else if (flagName == "SF" || flagName == "sf") value = Script::Flag::GetSF();
+                    else if (flagName == "TF" || flagName == "tf") value = Script::Flag::GetTF();
+                    else if (flagName == "AF" || flagName == "af") value = Script::Flag::GetAF();
+                    else if (flagName == "DF" || flagName == "df") value = Script::Flag::GetDF();
+                    else if (flagName == "IF" || flagName == "if") value = Script::Flag::GetIF();
+                    else {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Unknown flag");
+                        continue;
+                    }
+
+                    sendHttpResponse(clientSocket, 200, "text/plain", value ? "true" : "false");
+                } else if (path == "/Flag/Set") {
+                    std::string flagName = queryParams["flag"];
+                    std::string valueStr = queryParams["value"];
+                    if (flagName.empty() || valueStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing flag or value parameter");
+                        continue;
+                    }
+
+                    bool value = (valueStr == "true" || valueStr == "1");
+                    bool success = false;
+
+                    if (flagName == "ZF" || flagName == "zf") success = Script::Flag::SetZF(value);
+                    else if (flagName == "OF" || flagName == "of") success = Script::Flag::SetOF(value);
+                    else if (flagName == "CF" || flagName == "cf") success = Script::Flag::SetCF(value);
+                    else if (flagName == "PF" || flagName == "pf") success = Script::Flag::SetPF(value);
+                    else if (flagName == "SF" || flagName == "sf") success = Script::Flag::SetSF(value);
+                    else if (flagName == "TF" || flagName == "tf") success = Script::Flag::SetTF(value);
+                    else if (flagName == "AF" || flagName == "af") success = Script::Flag::SetAF(value);
+                    else if (flagName == "DF" || flagName == "df") success = Script::Flag::SetDF(value);
+                    else if (flagName == "IF" || flagName == "if") success = Script::Flag::SetIF(value);
+                    else {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Unknown flag");
+                        continue;
+                    }
+
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain",
+                                     success ? "Flag set successfully" : "Failed to set flag");
+                }
+
+                    // =============================================================================
+                    // PATTERN API ENDPOINTS
+                    // =============================================================================
+                else if (path == "/Pattern/FindMem") {
+                    std::string startStr = queryParams["start"];
+                    std::string sizeStr = queryParams["size"];
+                    std::string pattern = queryParams["pattern"];
+
+                    if (startStr.empty() || sizeStr.empty() || pattern.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing start, size, or pattern parameter");
+                        continue;
+                    }
+
+                    unsigned  int start = 0, size = 0;
+                    try {
+                        if (startStr.substr(0, 2) == "0x") {
+                            start = std::stoull(startStr.substr(2), nullptr, 16);
+                        } else {
+                            start = std::stoull(startStr, nullptr, 16);
+                        }
+                        size = std::stoull(sizeStr, nullptr, 10);
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid start or size format");
+                        continue;
+                    }
+
+                    unsigned  int result = Script::Pattern::FindMem(start, size, pattern.c_str());
+                    if (result != 0) {
+                        std::stringstream ss;
+                        ss << "0x" << std::hex << result;
+                        sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                    } else {
+                        sendHttpResponse(clientSocket, 404, "text/plain", "Pattern not found");
+                    }
+                }
+
+                    // =============================================================================
+                    // MISC API ENDPOINTS
+                    // =============================================================================
+                else if (path == "/Misc/ParseExpression") {
+                    std::string expression = queryParams["expression"];
+                    if (expression.empty() && !body.empty()) {
+                        expression = body;
+                    }
+
+                    if (expression.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing expression parameter");
+                        continue;
+                    }
+
+                    unsigned  int value = 0;
+                    bool success = Script::Misc::ParseExpression(expression.c_str(), &value);
+
+                    if (success) {
+                        std::stringstream ss;
+                        ss << "0x" << std::hex << value;
+                        sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                    } else {
+                        sendHttpResponse(clientSocket, 500, "text/plain", "Failed to parse expression");
+                    }
+                } else if (path == "/Misc/RemoteGetProcAddress") {
+                    std::string module = queryParams["module"];
+                    std::string api = queryParams["api"];
+
+                    if (module.empty() || api.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing module or api parameter");
+                        continue;
+                    }
+
+                    unsigned  int addr = Script::Misc::RemoteGetProcAddress(module.c_str(), api.c_str());
+                    if (addr != 0) {
+                        std::stringstream ss;
+                        ss << "0x" << std::hex << addr;
+                        sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                    } else {
+                        sendHttpResponse(clientSocket, 404, "text/plain", "Function not found");
+                    }
+                }
+
+                    // =============================================================================
+                    // EXISTING ENDPOINTS (Keep compatibility)
+                    // =============================================================================
+                else if (path == "/MemoryBase") {
+                    std::string addrStr = queryParams["addr"];
+                    if (addrStr.empty() && !body.empty()) {
+                        addrStr = body;
+                    }
+                    printf("MemoryBase endpoint called with addr: %s\n", addrStr.c_str());
+                    // Convert string address to duint
+                    unsigned  int addr = 0;
+                    try {
+                        addr = std::stoull(addrStr, nullptr, 16); // Parse as hex
+                    }
+                    catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+                    printf("Converted address: 0x%llx\n", addr);
+
+                    // Get the base address and size
+                    unsigned  int size = 0;
+                    unsigned  int baseAddr = DbgMemFindBaseAddr(addr, &size);
+                    printf("Base address found: 0x%llx, size: %llu\n", baseAddr, size);
+                    if (baseAddr == 0) {
+                        sendHttpResponse(clientSocket, 404, "text/plain", "No module found for this address");
+                    } else {
+                        // Format the response as JSON
+                        std::stringstream ss;
+                        ss << "{\"base_address\":\"0x" << std::hex << baseAddr << "\",\"size\":\"0x" << std::hex << size
+                           << "\"}";
+                        sendHttpResponse(clientSocket, 200, "application/json", ss.str());
+                    }
+                } else if (path == "/GetModuleList") {
+                    // Create a list to store the module information
+                    ListInfo moduleList;
+
+                    // Get the list of modules
+                    bool success = Script::Module::GetList(&moduleList);
+
+                    if (!success) {
+                        sendHttpResponse(clientSocket, 500, "text/plain", "Failed to get module list");
+                    } else {
+                        // Create a JSON array to hold the module information
+                        std::stringstream jsonResponse;
+                        jsonResponse << "[";
+
+                        // Iterate through each module in the list
+                        size_t count = moduleList.count;
+                        Script::Module::ModuleInfo *modules = (Script::Module::ModuleInfo *) moduleList.data;
+
+                        for (size_t i = 0; i < count; i++) {
+                            if (i > 0) jsonResponse << ",";
+
+                            // Add module info as JSON object
+                            jsonResponse << "{";
+                            jsonResponse << "\"name\":\"" << modules[i].name << "\",";
+                            jsonResponse << "\"base\":\"0x" << std::hex << modules[i].base << "\",";
+                            jsonResponse << "\"size\":\"0x" << std::hex << modules[i].size << "\",";
+                            jsonResponse << "\"entry\":\"0x" << std::hex << modules[i].entry << "\",";
+                            jsonResponse << "\"sectionCount\":" << std::dec << modules[i].sectionCount << ",";
+                            jsonResponse << "\"path\":\"" << modules[i].path << "\"";
+                            jsonResponse << "}";
+                        }
+
+                        jsonResponse << "]";
+
+                        // Free the list
+                        BridgeFree(moduleList.data);
+
+                        // Send the response
+                        sendHttpResponse(clientSocket, 200, "application/json", jsonResponse.str());
+                    }
+                }
+                    // Memory Access Functions (Legacy endpoints for compatibility)
+                else if (path == "/MemRead") {
+                    std::string addrStr = queryParams["addr"];
+                    std::string sizeStr = queryParams["size"];
+
+                    // URL decode parameters
+                    addrStr = urlDecode(addrStr);
+                    sizeStr = urlDecode(sizeStr);
+
+                    // Remove any quotes or extra characters
+                    addrStr.erase(std::remove_if(addrStr.begin(), addrStr.end(),
+                                                 [](char c) { return c == '"' || c == '\\'; }), addrStr.end());
+                    sizeStr.erase(std::remove_if(sizeStr.begin(), sizeStr.end(),
+                                                 [](char c) { return c == '"' || c == '\\'; }), sizeStr.end());
+
+                    if (addrStr.empty() || sizeStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address or size");
+                        closesocket(clientSocket);
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    unsigned  int size = 0;
+
+                    try {
+                        // Remove "0x" prefix if present
+                        if (addrStr.size() >= 2 && addrStr.substr(0, 2) == "0x") {
+                            addrStr = addrStr.substr(2);
+                        }
+
+                        addr = std::stoull(addrStr, nullptr, 16); // Parse address as hex
+                        size = std::stoull(sizeStr, nullptr, 10); // Parse size as decimal
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address or size format");
+                        closesocket(clientSocket);
+                        continue;
+                    }
+
+                    // Sanity check for size to prevent large allocations
+                    if (size > 1024 * 1024) { // Limit to 1MB for safety
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Size too large");
+                        closesocket(clientSocket);
+                        continue;
+                    }
+
+                    std::vector<unsigned char> buffer(size);
+
+                    if (!DbgMemRead(addr, buffer.data(), size)) {
+                        sendHttpResponse(clientSocket, 500, "text/plain", "Failed to read memory");
+                        closesocket(clientSocket);
+                        continue;
+                    }
+
+                    // Convert to hex string
+                    std::stringstream ss;
+                    for (size_t i = 0; i < size; i++) {
+                        ss << std::setw(2) << std::setfill('0') << std::hex << (int) buffer[i];
+                    }
+
+                    sendHttpResponse(clientSocket, 200, "text/plain", ss.str());
+                } else if (path == "/MemWrite") {
+                    std::string addrStr = queryParams["addr"];
+                    std::string dataStr = !body.empty() ? body : queryParams["data"];
+
+                    if (addrStr.empty() || dataStr.empty()) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Missing address or data");
+                        continue;
+                    }
+
+                    unsigned  int addr = 0;
+                    try {
+                        addr = std::stoull(addrStr, nullptr, 16); // Parse as hex
+                    } catch (const std::exception &e) {
+                        sendHttpResponse(clientSocket, 400, "text/plain", "Invalid address format");
+                        continue;
+                    }
+
+                    // Convert hex string to bytes
+                    std::vector<unsigned char> buffer;
+                    for (size_t i = 0; i < dataStr.length(); i += 2) {
+                        if (i + 1 >= dataStr.length()) break;
+                        std::string byteString = dataStr.substr(i, 2);
+                        try {
+                            unsigned char byte = (unsigned char) std::stoi(byteString, nullptr, 16);
+                            buffer.push_back(byte);
+                        } catch (const std::exception &e) {
+                            sendHttpResponse(clientSocket, 400, "text/plain", "Invalid data format");
+                            continue;
+                        }
+                    }
+
+                    // Write memory
+                    bool success = DbgMemWrite(addr, buffer.data(), buffer.size());
+                    sendHttpResponse(clientSocket, success ? 200 : 500, "text/plain",
+                                     success ? "Memory written successfully" : "Failed to write memory");
+                } 
+                */
+                else {
+                    // Unknown URL
+                    sendHttpResponse(clientSocket, 404, "text/plain", "Not Found");
+                }
+            }
+            catch (const std::exception &e) {
+                // Exception in handling request
+                sendHttpResponse(clientSocket, 500, "text/plain", std::string("Internal Server Error: ") + e.what());
+            }
+        }
+
+        // Close the client socket
+        closesocket(clientSocket);
+    }
+
+    // Clean up
+    if (g_serverSocket != INVALID_SOCKET) {
+        closesocket(g_serverSocket);
+        g_serverSocket = INVALID_SOCKET;
+    }
+
+    WSACleanup();
+    return 0;
+}
+
+// Function to read the HTTP request
+std::string readHttpRequest(SOCKET clientSocket) {
+    std::string request;
+    char buffer[MAX_REQUEST_SIZE];
+    int bytesReceived;
+
+    // Set socket to blocking mode to receive full request
+    u_long mode = 0;
+    ioctlsocket(clientSocket, FIONBIO, &mode);
+
+    // Receive data
+    bytesReceived = recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
+
+    if (bytesReceived > 0) {
+        buffer[bytesReceived] = '\0';
+        request = buffer;
+    }
+
+    return request;
+}
+
+// Function to parse an HTTP request
+void parseHttpRequest(const std::string &request, std::string &method, std::string &path, std::string &query,
+                      std::string &body) {
+    // Parse the request line
+    size_t firstLineEnd = request.find("\r\n");
+    if (firstLineEnd == std::string::npos) {
+        return;
+    }
+
+    std::string requestLine = request.substr(0, firstLineEnd);
+
+    // Extract method and URL
+    size_t methodEnd = requestLine.find(' ');
+    if (methodEnd == std::string::npos) {
+        return;
+    }
+
+    method = requestLine.substr(0, methodEnd);
+
+    size_t urlEnd = requestLine.find(' ', methodEnd + 1);
+    if (urlEnd == std::string::npos) {
+        return;
+    }
+
+    std::string url = requestLine.substr(methodEnd + 1, urlEnd - methodEnd - 1);
+
+    // Split URL into path and query
+    size_t queryStart = url.find('?');
+    if (queryStart != std::string::npos) {
+        path = url.substr(0, queryStart);
+        query = url.substr(queryStart + 1);
+    } else {
+        path = url;
+        query = "";
+    }
+
+    // Find the end of headers and start of body
+    size_t headersEnd = request.find("\r\n\r\n");
+    if (headersEnd == std::string::npos) {
+        return;
+    }
+
+    // Extract body
+    body = request.substr(headersEnd + 4);
+}
+
+// Function to send HTTP response
+void
+sendHttpResponse(SOCKET clientSocket, int statusCode, const std::string &contentType, const std::string &responseBody) {
+    // Prepare status line
+    std::string statusText;
+    switch (statusCode) {
+        case 200:
+            statusText = "OK";
+            break;
+        case 404:
+            statusText = "Not Found";
+            break;
+        case 500:
+            statusText = "Internal Server Error";
+            break;
+        default:
+            statusText = "Unknown";
+    }
+
+    // Build the response
+    std::stringstream response;
+    response << "HTTP/1.1 " << statusCode << " " << statusText << "\r\n";
+    response << "Content-Type: " << contentType << "\r\n";
+    response << "Content-Length: " << responseBody.length() << "\r\n";
+    response << "Connection: close\r\n";
+    response << "\r\n";
+    response << responseBody;
+
+    // Send the response
+    std::string responseStr = response.str();
+    send(clientSocket, responseStr.c_str(), (int) responseStr.length(), 0);
+}
+
+// Parse query parameters from URL
+std::unordered_map<std::string, std::string> parseQueryParams(const std::string &query) {
+    std::unordered_map<std::string, std::string> params;
+
+    size_t pos = 0;
+    size_t nextPos;
+
+    while (pos < query.length()) {
+        nextPos = query.find('&', pos);
+        if (nextPos == std::string::npos) {
+            nextPos = query.length();
+        }
+
+        std::string pair = query.substr(pos, nextPos - pos);
+        size_t equalPos = pair.find('=');
+
+        if (equalPos != std::string::npos) {
+            std::string key = pair.substr(0, equalPos);
+            std::string value = pair.substr(equalPos + 1);
+            params[key] = value;
+        }
+
+        pos = nextPos + 1;
+    }
+
+    return params;
+}
+
+// Command callback for toggling HTTP server
+bool cbEnableHttpServer(int argc, char *argv[]) {
+    if (g_httpServerRunning) {
+        printf("Stopping HTTP server...");
+        stopHttpServer();
+        printf("HTTP server stopped");
+    } else {
+        printf("Starting HTTP server...");
+        if (startHttpServer()) {
+            printf("HTTP server started on port %d\n", g_httpPort);
+        } else {
+            printf("Failed to start HTTP server");
+        }
+    }
+    return true;
+}
+
+// Command callback for changing HTTP server port
+bool cbSetHttpPort(int argc, char *argv[]) {
+    if (argc < 2) {
+        printf("Usage: httpport [port_number]");
+        return false;
+    }
+
+    int port1;
+    try {
+        port1 = std::stoi(argv[1]);
+    }
+    catch (const std::exception &) {
+        printf("Invalid port number");
+        return false;
+    }
+
+    if (port1 <= 0 || port1 > 65535) {
+        printf("Port number must be between 1 and 65535");
+        return false;
+    }
+
+    g_httpPort = port1;
+
+    if (g_httpServerRunning) {
+        printf("Restarting HTTP server with new port...");
+        stopHttpServer();
+        if (startHttpServer()) {
+            printf("HTTP server restarted on port %d\n", g_httpPort);
+        } else {
+            printf("Failed to restart HTTP server");
+        }
+    } else {
+        printf("HTTP port set to %d\n", g_httpPort);
+    }
+
+    return true;
+}
+
+// Register plugin commands
+void registerCommands() {
+//    _plugin_registercommand(g_pluginHandle, "httpserver", cbEnableHttpServer, "Toggle HTTP server on/off");
+//    _plugin_registercommand(g_pluginHandle, "httpport", cbSetHttpPort, "Set HTTP server port");
+}
\ No newline at end of file
Index: hyperdbg/libhyperdbg/code/export/mcp_api_meta.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/mcp_api_meta.json b/hyperdbg/libhyperdbg/code/export/mcp_api_meta.json
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/mcp_api_meta.json	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,631 @@
+[
+ {
+  "Name": "VmxSupportDetection",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "CpuReadVendorString",
+  "Params": [
+   {
+    "Name": "vendor_string",
+    "Type": "CHAR *"
+   }
+  ],
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "HyperDbgLoadVmmModule",
+  "Params": null,
+  "ReturnType": "INT"
+ },
+ {
+  "Name": "HyperDbgUnloadVmm",
+  "Params": null,
+  "ReturnType": "INT"
+ },
+ {
+  "Name": "HyperDbgInstallVmmDriver",
+  "Params": null,
+  "ReturnType": "INT"
+ },
+ {
+  "Name": "HyperDbgUninstallVmmDriver",
+  "Params": null,
+  "ReturnType": "INT"
+ },
+ {
+  "Name": "HyperDbgStopVmmDriver",
+  "Params": null,
+  "ReturnType": "INT"
+ },
+ {
+  "Name": "HyperDbgInterpreter",
+  "Params": [
+   {
+    "Name": "command",
+    "Type": "CHAR *"
+   }
+  ],
+  "ReturnType": "INT"
+ },
+ {
+  "Name": "HyperDbgTestCommandParser",
+  "Params": [
+   {
+    "Name": "command",
+    "Type": "CHAR *"
+   },
+   {
+    "Name": "number_of_tokens",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "tokens_list",
+    "Type": "CHAR **"
+   },
+   {
+    "Name": "failed_token_num",
+    "Type": "UINT32 *"
+   },
+   {
+    "Name": "failed_token_position",
+    "Type": "UINT32 *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgTestCommandParserShowTokens",
+  "Params": [
+   {
+    "Name": "command",
+    "Type": "CHAR *"
+   }
+  ],
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "HyperDbgShowSignature",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "SetTextMessageCallback",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "SetTextMessageCallbackUsingSharedBuffer",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "UnsetTextMessageCallback",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "ScriptReadFileAndExecuteCommandline",
+  "Params": [
+   {
+    "Name": "argc",
+    "Type": "INT"
+   },
+   {
+    "Name": "argv",
+    "Type": "CHAR *"
+   }
+  ],
+  "ReturnType": "INT"
+ },
+ {
+  "Name": "ContinuePreviousCommand",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "CheckMultilineCommand",
+  "Params": [
+   {
+    "Name": "current_command",
+    "Type": "CHAR *"
+   },
+   {
+    "Name": "reset",
+    "Type": "BOOLEAN"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "ConnectLocalDebugger",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "ConnectRemoteDebugger",
+  "Params": [
+   {
+    "Name": "ip",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "port",
+    "Type": "const CHAR *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "Continue",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "Pause",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "SetBreakPoint",
+  "Params": [
+   {
+    "Name": "address",
+    "Type": "UINT64"
+   },
+   {
+    "Name": "pid",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "tid",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "core_numer",
+    "Type": "UINT32"
+   }
+  ],
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "SetCustomDriverPath",
+  "Params": [
+   {
+    "Name": "driver_file_path",
+    "Type": "CHAR *"
+   },
+   {
+    "Name": "driver_name",
+    "Type": "CHAR *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "UseDefaultDriverPath",
+  "Params": null,
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "HyperDbgReadMemory",
+  "Params": [
+   {
+    "Name": "target_address",
+    "Type": "UINT64"
+   },
+   {
+    "Name": "memory_type",
+    "Type": "DEBUGGER_READ_MEMORY_TYPE"
+   },
+   {
+    "Name": "reading_Type",
+    "Type": "DEBUGGER_READ_READING_TYPE"
+   },
+   {
+    "Name": "pid",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "size",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "get_address_mode",
+    "Type": "BOOLEAN"
+   },
+   {
+    "Name": "address_mode",
+    "Type": "DEBUGGER_READ_MEMORY_ADDRESS_MODE *"
+   },
+   {
+    "Name": "target_buffer_to_store",
+    "Type": "BYTE *"
+   },
+   {
+    "Name": "return_length",
+    "Type": "UINT32 *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgShowMemoryOrDisassemble",
+  "Params": [
+   {
+    "Name": "style",
+    "Type": "DEBUGGER_SHOW_MEMORY_STYLE"
+   },
+   {
+    "Name": "address",
+    "Type": "UINT64"
+   },
+   {
+    "Name": "memory_type",
+    "Type": "DEBUGGER_READ_MEMORY_TYPE"
+   },
+   {
+    "Name": "reading_type",
+    "Type": "DEBUGGER_READ_READING_TYPE"
+   },
+   {
+    "Name": "pid",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "size",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "dt_details",
+    "Type": "PDEBUGGER_DT_COMMAND_OPTIONS"
+   }
+  ],
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "HyperDbgReadAllRegisters",
+  "Params": [
+   {
+    "Name": "guest_registers",
+    "Type": "GUEST_REGS *"
+   },
+   {
+    "Name": "extra_registers",
+    "Type": "GUEST_EXTRA_REGISTERS *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgReadTargetRegister",
+  "Params": [
+   {
+    "Name": "register_id",
+    "Type": "REGS_ENUM"
+   },
+   {
+    "Name": "target_register",
+    "Type": "UINT64 *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgWriteTargetRegister",
+  "Params": [
+   {
+    "Name": "register_id",
+    "Type": "REGS_ENUM"
+   },
+   {
+    "Name": "value",
+    "Type": "UINT64"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgRegisterShowAll",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgRegisterShowTargetRegister",
+  "Params": [
+   {
+    "Name": "register_id",
+    "Type": "REGS_ENUM"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgWriteMemory",
+  "Params": [
+   {
+    "Name": "destination_address",
+    "Type": "PVOID"
+   },
+   {
+    "Name": "memory_type",
+    "Type": "DEBUGGER_EDIT_MEMORY_TYPE"
+   },
+   {
+    "Name": "process_id",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "source_address",
+    "Type": "PVOID"
+   },
+   {
+    "Name": "number_of_bytes",
+    "Type": "UINT32"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "DebuggerGetKernelBase",
+  "Params": null,
+  "ReturnType": "UINT64"
+ },
+ {
+  "Name": "HyperDbgDebugRemoteDeviceUsingComPort",
+  "Params": [
+   {
+    "Name": "port_name",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "baudrate",
+    "Type": "DWORD"
+   },
+   {
+    "Name": "pause_after_connection",
+    "Type": "BOOLEAN"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgDebugRemoteDeviceUsingNamedPipe",
+  "Params": [
+   {
+    "Name": "named_pipe",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "pause_after_connection",
+    "Type": "BOOLEAN"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgDebugCloseRemoteDebugger",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgDebugCurrentDeviceUsingComPort",
+  "Params": [
+   {
+    "Name": "port_name",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "baudrate",
+    "Type": "DWORD"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "StartProcess",
+  "Params": [
+   {
+    "Name": "path",
+    "Type": "const WCHAR *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "StartProcessWithArgs",
+  "Params": [
+   {
+    "Name": "path",
+    "Type": "const WCHAR *"
+   },
+   {
+    "Name": "arguments",
+    "Type": "const WCHAR *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgAssembleGetLength",
+  "Params": [
+   {
+    "Name": "assembly_code",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "start_address",
+    "Type": "UINT64"
+   },
+   {
+    "Name": "length",
+    "Type": "UINT32 *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgAssemble",
+  "Params": [
+   {
+    "Name": "assembly_code",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "start_address",
+    "Type": "UINT64"
+   },
+   {
+    "Name": "buffer_to_store_assembled_data",
+    "Type": "PVOID"
+   },
+   {
+    "Name": "buffer_size",
+    "Type": "UINT32"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "SetupPathForFileName",
+  "Params": [
+   {
+    "Name": "filename",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "file_location",
+    "Type": "CHAR *"
+   },
+   {
+    "Name": "buffer_len",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "check_file_existence",
+    "Type": "BOOLEAN"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "SteppingInstrumentationStepIn",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "SteppingRegularStepIn",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "SteppingStepOver",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "SteppingInstrumentationStepInForTracking",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "SteppingStepOverForGu",
+  "Params": [
+   {
+    "Name": "last_instruction",
+    "Type": "BOOLEAN"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgGetLocalApic",
+  "Params": [
+   {
+    "Name": "local_apic",
+    "Type": "PLAPIC_PAGE"
+   },
+   {
+    "Name": "is_using_x2apic",
+    "Type": "BOOLEAN *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgGetIoApic",
+  "Params": [
+   {
+    "Name": "io_apic",
+    "Type": "IO_APIC_ENTRY_PACKETS *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgGetIdtEntry",
+  "Params": [
+   {
+    "Name": "idt_packet",
+    "Type": "INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS *"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HwdbgScriptRunScript",
+  "Params": [
+   {
+    "Name": "script",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "instance_filepath_to_read",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "hardware_script_file_path_to_save",
+    "Type": "const CHAR *"
+   },
+   {
+    "Name": "initial_bram_buffer_size",
+    "Type": "UINT32"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "ScriptEngineWrapperTestParserForHwdbg",
+  "Params": [
+   {
+    "Name": "Expr",
+    "Type": "const char *"
+   }
+  ],
+  "ReturnType": "VOID"
+ },
+ {
+  "Name": "HyperDbgEnableTransparentMode",
+  "Params": [
+   {
+    "Name": "ProcessId",
+    "Type": "UINT32"
+   },
+   {
+    "Name": "ProcessName",
+    "Type": "CHAR *"
+   },
+   {
+    "Name": "IsProcessId",
+    "Type": "BOOLEAN"
+   }
+  ],
+  "ReturnType": "BOOLEAN"
+ },
+ {
+  "Name": "HyperDbgDisableTransparentMode",
+  "Params": null,
+  "ReturnType": "BOOLEAN"
+ }
+]
\ No newline at end of file
Index: hyperdbg/libhyperdbg/code/export/mcp_test.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/mcp_test.go b/hyperdbg/libhyperdbg/code/export/mcp_test.go
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/mcp_test.go	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,927 @@
+package mcp
+
+import (
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+	"testing"
+
+	"github.com/ddkwork/golibrary/std/stream"
+)
+
+/* todo
+ *  make all commands json file
+ *  decode all error code text and send to client
+ */
+func Test_Bind_Go(t *testing.T) {
+	os.RemoveAll("bindings")
+	os.RemoveAll("tmp")
+	stream.MarshalJsonToFile(apis, "mcp_api_meta.json")
+	goType := map[string]string{
+		"BOOLEAN":                             "bool",
+		"BOOLEAN *":                           "bool", //todo see cpp server how to handle pointer
+		"INT":                                 "int",
+		"UINT32":                              "uint32",
+		"UINT32 *":                            "uint32", //todo see cpp server how to handle pointer
+		"UINT64":                              "uint64",
+		"UINT64 *":                            "uint64", //todo see cpp server how to handle pointer
+		"const CHAR *":                        "string",
+		"const char *":                        "string",
+		"const WCHAR *":                       "string", //todo utf16 ? 绑定其他枚举个结构体，调整很多返回值和形参位置移动
+		"CHAR *":                              "string",
+		"CHAR **":                             "[]string",
+		"VOID":                                "void",
+		"BYTE *":                              "[]byte", //todo test cpp server how to handle byte *
+		"DWORD":                               "uint32", //?
+		"PDEBUGGER_DT_COMMAND_OPTIONS":        "DEBUGGER_DT_COMMAND_OPTIONS",
+		"DEBUGGER_READ_MEMORY_ADDRESS_MODE *": "DEBUGGER_READ_MEMORY_ADDRESS_MODE",
+		"GUEST_REGS *":                        "GUEST_REGS",
+		"GUEST_EXTRA_REGISTERS *":             "GUEST_EXTRA_REGISTERS",
+		"INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS *": "INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS",
+		"IO_APIC_ENTRY_PACKETS *":                      "IO_APIC_ENTRY_PACKETS",
+		"DEBUGGER_READ_MEMORY_TYPE":                    "DEBUGGER_READ_MEMORY_TYPE",
+		"PVOID":                                        "uint64",
+		"REGS_ENUM":                                    "REGS_ENUM",
+		"DEBUGGER_EDIT_MEMORY_TYPE":                    "DEBUGGER_EDIT_MEMORY_TYPE",
+		"DEBUGGER_READ_READING_TYPE":                   "DEBUGGER_READ_READING_TYPE",
+		"DEBUGGER_SHOW_MEMORY_STYLE":                   "DEBUGGER_SHOW_MEMORY_STYLE",
+		"PLAPIC_PAGE":                                  "PLAPIC_PAGE",
+		//    mcp_test.go:87: unknown param type: register_id
+	}
+	g := stream.NewGeneratedFile()
+	g.P("type debugger struct {}")
+	for _, api := range apis {
+		api.Name = strings.TrimPrefix(api.Name, "HyperDbg")
+		params := ""
+		for i, param := range api.Params {
+			params += param.Name + " " + goType[param.Type]
+			if i < len(api.Params)-1 {
+				params += ", "
+			}
+		}
+		returnType := goType[api.ReturnType]
+		returnSyntax := "return"
+		if api.ReturnType == "VOID" {
+			returnType = ""
+			returnSyntax = ""
+		}
+		g.P("func (debugger) ", api.Name, "("+params, ") ", returnType, " {")
+
+		var callParams string
+		for i, param := range api.Params {
+			callParams += "\t\t" + strconv.Quote(param.Name) + ":"
+			switch param.Type {
+			case "BOOLEAN", "BOOLEAN *":
+				callParams += "strconv.FormatBool(" + param.Name + ")"
+			case "INT":
+				callParams += "strconv.Itoa(" + param.Name + ")"
+			case "UINT32", "DWORD", "UINT32 *": //todo see cpp server how to handle pointer
+				callParams += "strconv.FormatUint(uint64(" + param.Name + "), 10)"
+			case "UINT64":
+				callParams += "strconv.FormatUint(" + param.Name + ", 10)"
+			//case "const CHAR *":
+			//	callParams += param.Name
+			case "CHAR **":
+				callParams += "strings.Join(tokens_list, " +
+					"\" \"" + //todo test cpp server how to handle char **")
+					")"
+			case "const WCHAR *":
+				callParams += param.Name
+			case "CHAR *", "const CHAR *", "const char *":
+				callParams += param.Name
+			case "BYTE *":
+				callParams += "hex.EncodeToString(" + param.Name + ")"
+			case "VOID":
+				callParams += "None"
+			case "PDEBUGGER_DT_COMMAND_OPTIONS",
+				"PDEBUGGER_DT_COMMAND_OPTIONS *",
+				"GUEST_REGS *",
+				"IO_APIC_ENTRY_PACKETS *",
+				"GUEST_EXTRA_REGISTERS *",
+				"INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS *",
+				"PLAPIC_PAGE *",
+				"IO_APIC_ENTRY_PACKETS",
+				"INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS",
+				"GUEST_REGS",
+				"PLAPIC_PAGE",
+				"GUEST_EXTRA_REGISTERS":
+				callParams += "string(stream.MarshalJSON(" + param.Name + "))"
+			case "DEBUGGER_EDIT_MEMORY_TYPE",
+				"DEBUGGER_READ_READING_TYPE",
+				"DEBUGGER_SHOW_MEMORY_STYLE",
+				"DEBUGGER_READ_MEMORY_TYPE",
+				"DEBUGGER_READ_MEMORY_ADDRESS_MODE",
+				"DEBUGGER_READ_MEMORY_ADDRESS_MODE *",
+				"REGS_ENUM",
+				"REGS_ENUM *",
+				"DEBUGGER_EDIT_MEMORY_TYPE *",
+				"DEBUGGER_READ_READING_TYPE *",
+				"DEBUGGER_SHOW_MEMORY_STYLE *",
+				"DEBUGGER_READ_MEMORY_TYPE *",
+				"UINT64 *",
+				"PVOID":
+				callParams += "strconv.FormatUint(uint64(" + param.Name + "),10)"
+
+			default:
+				callParams += strconv.Quote("todo panic --> unknown param type:" + param.Type)
+				t.Error("unknown param type:", param.Type, " api:", api.Name)
+			}
+			if api.Name == "Interpreter" { //for debug
+				//println()
+			}
+			if i < len(api.Params) {
+				callParams += ","
+			}
+			if len(api.Params) > 1 {
+				if i == 0 {
+					callParams = "\n" + callParams
+				}
+				callParams += "\n"
+			}
+		}
+		paramsMap := "map[string]string{" + callParams + "}"
+		if api.Params == nil {
+			paramsMap = "nil"
+		}
+		g.P("\t", returnSyntax, " request[", goType[api.ReturnType], "](", strconv.Quote(api.Name), ",", paramsMap, ")")
+		g.P("}")
+	}
+	g.AddImport("strings")
+	g.AddImport("encoding/hex")
+	//g.AddImport("encoding/json")
+	g.AddImport("github.com/ddkwork/golibrary/std/stream")
+	//g.AddImport("fmt")
+	g.AddImport("strconv")
+	g.InsertPackageWithImports("sdk")
+	b := stream.NewBuffer("request.go").ReplaceAll("package mcp", "package sdk")
+	stream.WriteGoFile("bindings/go/sdk/request.go", b.String())
+	//stream.WriteGoFile("tmp/bindings/go/sdk/request.go", b.String())
+	stream.WriteGoFile(filepath.Join("bindings/go/sdk/sdk.go"), g.String())
+
+	//generate other language bindings
+	Test_Bind_V(t)
+	Test_Bind_Python(t)
+	Test_Gen_Cpp_Server_Code(t)
+	Test_Bind_Csharp(t)
+	Test_Bind_Javascript(t)
+	Test_Bind_Rust(t)
+	Test_Bind_Java(t)
+	Test_Bind_Haskell(t)
+	Test_Bind_Masm(t)
+	Test_Bind_Nodejs(t)
+	Test_Bind_Ocaml(t)
+	Test_Bind_PowerShell(t)
+	Test_Bind_Ruby(t)
+	Test_Bind_Vb6(t)
+}
+func Test_Bind_V(t *testing.T) {}
+func Test_Bind_Python(t *testing.T) {
+	start := `
+import sys
+import requests
+import json
+
+from mcp.server.fastmcp import FastMCP
+
+DEFAULT_HyperDBG_SERVER = "http://127.0.0.1:8888/"
+hyperdbg_server_url = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HyperDBG_SERVER
+
+mcp = FastMCP("hyperdbg-mcp")
+
+def safe_get(endpoint: str, params: dict = None):
+    """
+    Perform a GET request with optional query parameters.
+    Returns parsed JSON if possible, otherwise text content
+    """
+    if params is None:
+        params = {}
+
+    url = f"{hyperdbg_server_url}{endpoint}"
+
+    try:
+        response = requests.get(url, params=params, timeout=15)
+        response.encoding = 'utf-8'
+        if response.ok:
+            # Try to parse as JSON first
+            try:
+                return response.json()
+            except ValueError:
+                return response.text.strip()
+        else:
+            return f"Error {response.status_code}: {response.text.strip()}"
+    except Exception as e:
+        return f"Request failed: {str(e)}"
+
+def safe_post(endpoint: str, data: dict | str):
+    """
+    Perform a POST request with data.
+    Returns parsed JSON if possible, otherwise text content
+    """
+    try:
+        url = f"{hyperdbg_server_url}{endpoint}"
+        if isinstance(data, dict):
+            response = requests.post(url, data=data, timeout=5)
+        else:
+            response = requests.post(url, data=data.encode("utf-8"), timeout=5)
+        
+        response.encoding = 'utf-8'
+        
+        if response.ok:
+            # Try to parse as JSON first
+            try:
+                return response.json()
+            except ValueError:
+                return response.text.strip()
+        else:
+            return f"Error {response.status_code}: {response.text.strip()}"
+    except Exception as e:
+        return f"Request failed: {str(e)}"
+`
+	g := stream.NewGeneratedFile()
+	g.P(start)
+	for _, api := range apis {
+		g.P("@mcp.tool()")
+		//ai model 提示词
+		g.P("def ", api.Name, "()")
+		//g.P("    return safe_post('mcp/api/"+api.Name+"', {'"+api.Params[0].Name+"': "+api.Params[0].Name+"})")
+		g.P("")
+	}
+	g.P("if __name__ == \"__main__\":\n    mcp.run()")
+	stream.WriteTruncate("bindings/python/sdk.py", g.String())
+}
+
+func Test_Gen_Cpp_Server_Code(t *testing.T) {}
+func Test_Bind_Csharp(t *testing.T)         {}
+func Test_Bind_Javascript(t *testing.T)     {}
+func Test_Bind_Rust(t *testing.T)           {}
+func Test_Bind_Java(t *testing.T)           {}
+func Test_Bind_Haskell(t *testing.T)        {}
+func Test_Bind_Masm(t *testing.T)           {}
+func Test_Bind_Nodejs(t *testing.T)         {}
+func Test_Bind_Ocaml(t *testing.T)          {}
+func Test_Bind_PowerShell(t *testing.T)     {}
+func Test_Bind_Ruby(t *testing.T)           {}
+func Test_Bind_Vb6(t *testing.T)            {}
+
+type ApiMeta struct {
+	Name       string
+	Params     []NameType
+	ReturnType string
+}
+
+type NameType struct {
+	Name string
+	Type string
+}
+
+var apis = []ApiMeta{
+	{
+		Name:       "VmxSupportDetection",
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "CpuReadVendorString",
+		Params: []NameType{
+			{
+				Name: "vendor_string",
+				Type: "CHAR *",
+			},
+		},
+		ReturnType: "VOID",
+	},
+	{
+		Name:       "HyperDbgLoadVmmModule",
+		Params:     nil,
+		ReturnType: "INT", //? INT Returns 0 if it was successful and 1 if it was failed
+	},
+	{
+		Name:       "HyperDbgUnloadVmm",
+		Params:     nil,
+		ReturnType: "INT",
+	},
+	{
+		Name:       "HyperDbgInstallVmmDriver",
+		Params:     nil,
+		ReturnType: "INT",
+	},
+
+	{
+		Name:       "HyperDbgUninstallVmmDriver",
+		Params:     nil,
+		ReturnType: "INT",
+	},
+	{
+		Name:       "HyperDbgStopVmmDriver",
+		Params:     nil,
+		ReturnType: "INT",
+	},
+	{
+		Name: "HyperDbgInterpreter", // RunCommand
+		Params: []NameType{
+			{
+				Name: "command",
+				Type: "CHAR *",
+			},
+		},
+		ReturnType: "INT",
+	},
+
+	{
+		Name: "HyperDbgTestCommandParser",
+		Params: []NameType{
+			{
+				Name: "command",
+				Type: "CHAR *",
+			},
+			{
+				Name: "number_of_tokens",
+				Type: "UINT32",
+			},
+			{
+				Name: "tokens_list",
+				Type: "CHAR **", //?todo how to format this
+			},
+			{
+				Name: "failed_token_num",
+				Type: "UINT32 *",
+			},
+			{
+				Name: "failed_token_position",
+				Type: "UINT32 *",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgTestCommandParserShowTokens",
+		Params: []NameType{
+			{
+				Name: "command",
+				Type: "CHAR *",
+			},
+		},
+		ReturnType: "VOID",
+	},
+
+	{
+		Name:       "HyperDbgShowSignature",
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name:       "SetTextMessageCallback", //todo remove
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name:       "SetTextMessageCallbackUsingSharedBuffer", //todo remove
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name:       "UnsetTextMessageCallback", //todo remove
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name: "ScriptReadFileAndExecuteCommandline",
+		Params: []NameType{
+			{
+				Name: "argc",
+				Type: "INT",
+			},
+			{
+				Name: "argv",
+				Type: "CHAR *",
+			},
+		},
+		ReturnType: "INT",
+	},
+
+	{
+		Name:       "ContinuePreviousCommand",
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+
+	{
+		Name: "CheckMultilineCommand",
+		Params: []NameType{
+			{
+				Name: "current_command",
+				Type: "CHAR *",
+			},
+			{
+				Name: "reset",
+				Type: "BOOLEAN",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	///////////////////////////////////////////////////
+	{
+		Name:       "ConnectLocalDebugger",
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name: "ConnectRemoteDebugger",
+		Params: []NameType{
+			{
+				Name: "ip",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "port",
+				Type: "const CHAR *",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "Continue", //c api CommandGRequest
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name:       "Pause", //c api CommandPauseRequest
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name: "SetBreakPoint", //c api CommandBpRequest
+		Params: []NameType{
+			{
+				Name: "address",
+				Type: "UINT64",
+			},
+			{
+				Name: "pid",
+				Type: "UINT32",
+			},
+			{
+				Name: "tid",
+				Type: "UINT32",
+			}, {
+				Name: "core_numer",
+				Type: "UINT32",
+			},
+		},
+		ReturnType: "VOID",
+	},
+	{
+		Name: "SetCustomDriverPath", //set_custom_driver_path , no c api
+		Params: []NameType{
+			{
+				Name: "driver_file_path",
+				Type: "CHAR *",
+			},
+			{
+				Name: "driver_name",
+				Type: "CHAR *",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "UseDefaultDriverPath", //use_default_driver_path,NO c api
+		Params:     nil,
+		ReturnType: "VOID",
+	},
+	{
+		Name: "HyperDbgReadMemory", //todo 处理参数是指针类型的格式化操作，参数太多了
+		Params: []NameType{
+			{
+				Name: "target_address",
+				Type: "UINT64",
+			},
+			{
+				Name: "memory_type",
+				Type: "DEBUGGER_READ_MEMORY_TYPE", //todo gen enum type
+			},
+			{
+				Name: "reading_Type",
+				Type: "DEBUGGER_READ_READING_TYPE",
+			},
+			{
+				Name: "pid",
+				Type: "UINT32",
+			},
+			{
+				Name: "size",
+				Type: "UINT32",
+			},
+			{
+				Name: "get_address_mode",
+				Type: "BOOLEAN",
+			},
+			{
+				Name: "address_mode",
+				Type: "DEBUGGER_READ_MEMORY_ADDRESS_MODE *",
+			},
+			{
+				Name: "target_buffer_to_store",
+				Type: "BYTE *",
+			},
+			{
+				Name: "return_length",
+				Type: "UINT32 *",
+			},
+		},
+		ReturnType: "BOOLEAN", //todo 改变返回值类型 bytes buffer return need to be changed
+	},
+	{
+		Name: "HyperDbgShowMemoryOrDisassemble",
+		Params: []NameType{
+			{
+				Name: "style",
+				Type: "DEBUGGER_SHOW_MEMORY_STYLE",
+			},
+			{
+				Name: "address",
+				Type: "UINT64",
+			},
+			{
+				Name: "memory_type",
+				Type: "DEBUGGER_READ_MEMORY_TYPE",
+			},
+			{
+				Name: "reading_type",
+				Type: "DEBUGGER_READ_READING_TYPE",
+			},
+			{
+				Name: "pid",
+				Type: "UINT32",
+			},
+			{
+				Name: "size",
+				Type: "UINT32",
+			},
+			{
+				Name: "dt_details",
+				Type: "PDEBUGGER_DT_COMMAND_OPTIONS",
+			},
+		},
+		ReturnType: "VOID", //TODO
+	},
+	{
+		Name: "HyperDbgReadAllRegisters",
+		Params: []NameType{
+			{
+				Name: "guest_registers",
+				Type: "GUEST_REGS *",
+			},
+			{
+				Name: "extra_registers",
+				Type: "GUEST_EXTRA_REGISTERS *",
+			},
+		},
+		ReturnType: "BOOLEAN", //todo 返回结构体
+	},
+	//{
+	//	Name: "xxxxxxxxxxxxxxxxxxx",
+	//	Params: []NameType{
+	//		{
+	//			Name: "xxxxxxxxxxxxxx",
+	//			Type: "xxxxxxxxxxxxxxx",
+	//		},
+	//		{
+	//			Name: "xxxxxxxxxx",
+	//			Type: "xxxxxxxxxx",
+	//		},
+	//	},
+	//	ReturnType: "xxxxxxxxxxxxxxxxx",
+	//},
+	{
+		Name: "HyperDbgReadTargetRegister",
+		Params: []NameType{
+			{
+				Name: "register_id",
+				Type: "REGS_ENUM",
+			},
+			{
+				Name: "target_register",
+				Type: "UINT64 *",
+			},
+		},
+		ReturnType: "BOOLEAN", //todo 返回结构体
+	},
+	{
+		Name: "HyperDbgWriteTargetRegister",
+		Params: []NameType{
+			{
+				Name: "register_id",
+				Type: "REGS_ENUM",
+			},
+			{
+				Name: "value",
+				Type: "UINT64",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "HyperDbgRegisterShowAll", //?
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgRegisterShowTargetRegister",
+		Params: []NameType{
+			{
+				Name: "register_id",
+				Type: "REGS_ENUM",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgWriteMemory",
+		Params: []NameType{
+			{
+				Name: "destination_address",
+				Type: "PVOID",
+			},
+			{
+				Name: "memory_type",
+				Type: "DEBUGGER_EDIT_MEMORY_TYPE",
+			},
+			{
+				Name: "process_id",
+				Type: "UINT32",
+			},
+			{
+				Name: "source_address",
+				Type: "PVOID",
+			},
+			{
+				Name: "number_of_bytes",
+				Type: "UINT32",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "DebuggerGetKernelBase",
+		Params:     nil,
+		ReturnType: "UINT64",
+	},
+	{
+		Name: "HyperDbgDebugRemoteDeviceUsingComPort",
+		Params: []NameType{
+			{
+				Name: "port_name",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "baudrate",
+				Type: "DWORD",
+			},
+			{
+				Name: "pause_after_connection",
+				Type: "BOOLEAN",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgDebugRemoteDeviceUsingNamedPipe",
+		Params: []NameType{
+			{
+				Name: "named_pipe",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "pause_after_connection",
+				Type: "BOOLEAN",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "HyperDbgDebugCloseRemoteDebugger",
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgDebugCurrentDeviceUsingComPort",
+		Params: []NameType{
+			{
+				Name: "port_name",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "baudrate",
+				Type: "DWORD",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "StartProcess",
+		Params: []NameType{
+			{
+				Name: "path",
+				Type: "const WCHAR *", //todo
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "StartProcessWithArgs",
+		Params: []NameType{
+			{
+				Name: "path",
+				Type: "const WCHAR *",
+			},
+			{
+				Name: "arguments",
+				Type: "const WCHAR *",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgAssembleGetLength",
+		Params: []NameType{
+			{
+				Name: "assembly_code",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "start_address",
+				Type: "UINT64",
+			},
+			{
+				Name: "length",
+				Type: "UINT32 *", //todo move to return
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgAssemble",
+		Params: []NameType{
+			{
+				Name: "assembly_code",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "start_address",
+				Type: "UINT64",
+			},
+			{
+				Name: "buffer_to_store_assembled_data",
+				Type: "PVOID",
+			},
+			{
+				Name: "buffer_size", //?
+				Type: "UINT32",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "SetupPathForFileName",
+		Params: []NameType{
+			{
+				Name: "filename",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "file_location",
+				Type: "CHAR *",
+			},
+			{
+				Name: "buffer_len",
+				Type: "UINT32",
+			},
+			{
+				Name: "check_file_existence",
+				Type: "BOOLEAN",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "SteppingInstrumentationStepIn", //todo rename
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "SteppingRegularStepIn",
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "SteppingStepOver",
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "SteppingInstrumentationStepInForTracking",
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "SteppingStepOverForGu",
+		Params: []NameType{
+			{
+				Name: "last_instruction",
+				Type: "BOOLEAN",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgGetLocalApic",
+		Params: []NameType{
+			{
+				Name: "local_apic",
+				Type: "PLAPIC_PAGE",
+			},
+			{
+				Name: "is_using_x2apic",
+				Type: "BOOLEAN *", //?
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgGetIoApic",
+		Params: []NameType{
+			{
+				Name: "io_apic",
+				Type: "IO_APIC_ENTRY_PACKETS *", //?
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HyperDbgGetIdtEntry",
+		Params: []NameType{
+			{
+				Name: "idt_packet",
+				Type: "INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS *", //todo move into return
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "HwdbgScriptRunScript",
+		Params: []NameType{
+			{
+				Name: "script",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "instance_filepath_to_read",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "hardware_script_file_path_to_save",
+				Type: "const CHAR *",
+			},
+			{
+				Name: "initial_bram_buffer_size",
+				Type: "UINT32",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name: "ScriptEngineWrapperTestParserForHwdbg",
+		Params: []NameType{
+			{
+				Name: "Expr",
+				Type: "const char *",
+			},
+		},
+		ReturnType: "VOID",
+	},
+	{
+		Name: "HyperDbgEnableTransparentMode",
+		Params: []NameType{
+			{
+				Name: "ProcessId",
+				Type: "UINT32",
+			},
+			{
+				Name: "ProcessName",
+				Type: "CHAR *",
+			},
+			{
+				Name: "IsProcessId",
+				Type: "BOOLEAN",
+			},
+		},
+		ReturnType: "BOOLEAN",
+	},
+	{
+		Name:       "HyperDbgDisableTransparentMode",
+		Params:     nil,
+		ReturnType: "BOOLEAN",
+	},
+}
Index: hyperdbg/libhyperdbg/code/export/request.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/code/export/request.go b/hyperdbg/libhyperdbg/code/export/request.go
new file mode 100644
--- /dev/null	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
+++ b/hyperdbg/libhyperdbg/code/export/request.go	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -0,0 +1,499 @@
+package mcp
+
+import (
+	"cmp"
+	"encoding/hex"
+	"fmt"
+	"io"
+	"net/http"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/ddkwork/golibrary/std/mylog"
+)
+
+const DefaultHyperdbgServer = "http://127.0.0.1:8888/"
+
+var client = &http.Client{
+	Timeout: 15 * time.Second,
+	Transport: &http.Transport{
+		DisableKeepAlives: true,
+	},
+}
+
+//	Type type Ordered interface {
+//		~int | ~int8 | ~int16 | ~int32 | ~int64 |
+//			~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
+//			~float32 | ~float64 |
+//			~string
+//	}
+type Type interface {
+	cmp.Ordered |
+		bool |
+		[]byte |
+		void
+	//moduleInfo |
+	//[]moduleInfo |
+	//moduleSectionInfo |
+	//[]moduleSectionInfo |
+	//moduleExport |
+	//[]moduleExport |
+	//moduleImport |
+	//[]moduleImport |
+	//memoryBase |
+	//disassemblerAddress |
+	//disassembleRip |
+	//disassembleRipWithSetupIn |
+	//assemblerResult |
+}
+type void any
+
+func request[T Type](endpoint string, params map[string]string) T {
+	x64dbgServerURL := DefaultHyperdbgServer
+	url := x64dbgServerURL + endpoint
+
+	// 添加查询参数
+	if len(params) > 0 {
+		query := ""
+		for key, value := range params {
+			query += key + "=" + value + "&"
+		}
+		url += "?" + strings.TrimSuffix(query, "&")
+	}
+
+	resp := mylog.Check2(client.Get(url))
+	defer func() {
+		mylog.Check(resp.Body.Close())
+	}()
+
+	body := mylog.Check2(io.ReadAll(resp.Body))
+
+	if resp.StatusCode != http.StatusOK {
+		mylog.Check(fmt.Sprintf("Error %d: %s", resp.StatusCode, string(body)))
+	}
+
+	str := strings.TrimSpace(string(body))
+	base := 10
+	if strings.HasPrefix(str, "0x") {
+		base = 16
+	}
+	str = strings.TrimPrefix(str, "0x")
+	var zero T
+	switch v := any(zero).(type) {
+	case bool:
+		if strings.EqualFold(str, "true") {
+			return any(true).(T)
+		}
+		if strings.EqualFold(str, "false") {
+			return any(false).(T)
+		}
+	case []byte:
+		b := mylog.Check2(hex.DecodeString(str))
+		return any(b).(T)
+	case int:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 64))
+		return any(value).(T)
+	case int8:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 8))
+		return any(value).(T)
+	case int16:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 16))
+		return any(value).(T)
+	case int32:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 32))
+		return any(value).(T)
+	case int64:
+
+		value := mylog.Check2(strconv.ParseInt(str, base, 64))
+		return any(value).(T)
+	case uint:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 64))
+		return any(value).(T)
+	case uint8:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 8))
+		return any(value).(T)
+	case uint16:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 16))
+		return any(value).(T)
+	case uint32:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 32))
+		return any(value).(T)
+	case uint64:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 64))
+		return any(value).(T)
+	case uintptr:
+
+		value := mylog.Check2(strconv.ParseUint(str, base, 64))
+		return any(value).(T)
+	case float32:
+		value := mylog.Check2(strconv.ParseFloat(str, 32))
+		return any(value).(T)
+	case float64:
+		value := mylog.Check2(strconv.ParseFloat(str, 64))
+		return any(value).(T)
+	case string:
+		return any(str).(T)
+
+		//todo 处理cpp服务端的字段返回 0x12345678 这种格式，我估计json会解码失败
+	//case moduleInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case moduleSectionInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleSectionInfo:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case moduleExport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleExport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case moduleImport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case []moduleImport:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case memoryBase:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case disassemblerAddress:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case disassembleRip:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case disassembleRipWithSetupIn:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	//case assemblerResult:
+	//	mylog.Check(json.Unmarshal(body, &v))
+	//	return any(v).(T)
+	case void:
+		v = v
+		return any(nil).(T)
+
+	}
+	panic("not support type")
+}
+
+type (
+	DEBUGGER_READ_MEMORY_ADDRESS_MODE byte
+	DEBUGGER_READ_MEMORY_TYPE         byte
+	DEBUGGER_EDIT_MEMORY_TYPE         byte
+	DEBUGGER_READ_READING_TYPE        byte
+	REGS_ENUM                         byte
+	DEBUGGER_SHOW_MEMORY_STYLE        byte
+)
+
+const (
+	DEBUGGER_SHOW_COMMAND_DT DEBUGGER_SHOW_MEMORY_STYLE = iota + 1
+	DEBUGGER_SHOW_COMMAND_DISASSEMBLE64
+	DEBUGGER_SHOW_COMMAND_DISASSEMBLE32
+	DEBUGGER_SHOW_COMMAND_DB
+	DEBUGGER_SHOW_COMMAND_DC
+	DEBUGGER_SHOW_COMMAND_DQ
+	DEBUGGER_SHOW_COMMAND_DD
+	DEBUGGER_SHOW_COMMAND_DUMP
+)
+
+const (
+	READ_FROM_KERNEL DEBUGGER_READ_READING_TYPE = iota
+	READ_FROM_VMX_ROOT
+)
+
+const (
+	EDIT_VIRTUAL_MEMORY DEBUGGER_EDIT_MEMORY_TYPE = iota
+	EDIT_PHYSICAL_MEMORY
+)
+
+const (
+	DEBUGGER_READ_PHYSICAL_ADDRESS DEBUGGER_READ_MEMORY_TYPE = iota
+	DEBUGGER_READ_VIRTUAL_ADDRESS
+)
+
+const (
+	DEBUGGER_READ_ADDRESS_MODE_32_BIT DEBUGGER_READ_MEMORY_ADDRESS_MODE = iota
+	DEBUGGER_READ_ADDRESS_MODE_64_BIT
+)
+const MAX_NUMBER_OF_IDT_ENTRIES = 256
+const MAX_NUMBER_OF_IO_APIC_ENTRIES = 400
+
+type (
+	INTERRUPT_DESCRIPTOR_TABLE_ENTRIES_PACKETS struct {
+		KernelStatus uint32
+		IdtEntry     [MAX_NUMBER_OF_IDT_ENTRIES]uint64
+	}
+
+	IO_APIC_ENTRY_PACKETS struct {
+		ApicBasePa uint64
+		ApicBaseVa uint64
+		IoIdReg    uint32
+		IoLl       uint32
+		IoArbIdReg uint32
+		LlLhData   [MAX_NUMBER_OF_IO_APIC_ENTRIES]uint64
+	}
+
+	DEBUGGER_DT_COMMAND_OPTIONS struct {
+		TypeName             string
+		SizeOfTypeName       uint64
+		Address              uint64
+		IsStruct             bool
+		BufferAddress        uintptr
+		TargetPid            uint32
+		AdditionalParameters string
+	}
+
+	GUEST_REGS struct { //todo export for json marshal
+		rax uint64
+		rcx uint64
+		rdx uint64
+		rbx uint64
+		rsp uint64
+		rbp uint64
+		rsi uint64
+		rdi uint64
+		r8  uint64
+		r9  uint64
+		r10 uint64
+		r11 uint64
+		r12 uint64
+		r13 uint64
+		r14 uint64
+		r15 uint64
+	}
+
+	GUEST_EXTRA_REGISTERS struct {
+		CS     uint16
+		DS     uint16
+		FS     uint16
+		GS     uint16
+		ES     uint16
+		SS     uint16
+		RFLAGS uint64
+		RIP    uint64
+	}
+)
+
+// LAPIC_PAGE 表示本地高级可编程中断控制器(LAPIC)的寄存器页面布局
+// 总大小固定为 0x400 字节 (1024 字节)
+type LAPIC_PAGE struct {
+	Reserved000             [0x10]byte // 偏移 0x00-0x0F
+	Reserved010             [0x10]byte // 偏移 0x10-0x1F
+	Id                      uint32     // 偏移 0x020 - APIC ID
+	Reserved024             [0x0C]byte // 偏移 0x024-0x02F
+	Version                 uint32     // 偏移 0x030 - 版本号
+	Reserved034             [0x0C]byte // 偏移 0x034-0x03F
+	Reserved040             [0x40]byte // 偏移 0x040-0x07F
+	TPR                     uint32     // 偏移 0x080 - 任务优先级
+	Reserved084             [0x0C]byte // 偏移 0x084-0x08F
+	ArbitrationPriority     uint32     // 偏移 0x090 - 仲裁优先级
+	Reserved094             [0x0C]byte // 偏移 0x094-0x09F
+	ProcessorPriority       uint32     // 偏移 0x0A0 - 处理器优先级
+	Reserved0A4             [0x0C]byte // 偏移 0x0A4-0x0AF
+	EOI                     uint32     // 偏移 0x0B0 - 中断结束寄存器
+	Reserved0B4             [0x0C]byte // 偏移 0x0B4-0x0BF
+	RemoteRead              uint32     // 偏移 0x0C0 - 远程读寄存器
+	Reserved0C4             [0x0C]byte // 偏移 0x0C4-0x0CF
+	LogicalDestination      uint32     // 偏移 0x0D0 - 逻辑目标寄存器
+	Reserved0D4             [0x0C]byte // 偏移 0x0D4-0x0DF
+	DestinationFormat       uint32     // 偏移 0x0E0 - 目标格式寄存器
+	Reserved0E4             [0x0C]byte // 偏移 0x0E4-0x0EF
+	SpuriousInterruptVector uint32     // 偏移 0x0F0 - 伪中断向量
+	Reserved0F4             [0x0C]byte // 偏移 0x0F4-0x0FF
+	ISR                     [8]uint32  // 偏移 0x100-0x13F (实际32位数组，分8个32位组存储)
+	//_                           [0x40]byte   // 对齐填充 0x140-0x17F
+	TMR [8]uint32 // 偏移 0x180-0x1BF (实际32位数组，分8个32位组存储)
+	//_                           [0x40]byte   // 对齐填充 0x1C0-0x1FF
+	IRR [8]uint32 // 偏移 0x200-0x23F (实际32位数组，分8个32位组存储)
+	//_                           [0x40]byte   // 对齐填充 0x240-0x27F
+	ErrorStatus         uint32     // 偏移 0x280 - 错误状态寄存器
+	Reserved284         [0x0C]byte // 偏移 0x284-0x28F
+	Reserved290         [0x60]byte // 偏移 0x290-0x2EF
+	LvtCmci             uint32     // 偏移 0x2F0 - CMCI中断向量
+	Reserved2F4         [0x0C]byte // 偏移 0x2F4-0x2FF
+	IcrLow              uint32     // 偏移 0x300 - 中断命令寄存器低32位
+	Reserved304         [0x0C]byte // 偏移 0x304-0x30F
+	IcrHigh             uint32     // 偏移 0x310 - 中断命令寄存器高32位
+	Reserved314         [0x0C]byte // 偏移 0x314-0x31F
+	LvtTimer            uint32     // 偏移 0x320 - 定时器中断向量
+	Reserved324         [0x0C]byte // 偏移 0x324-0x32F
+	LvtThermalSensor    uint32     // 偏移 0x330 - 热传感器中断向量
+	Reserved334         [0x0C]byte // 偏移 0x334-0x33F
+	LvtPerfMonCounters  uint32     // 偏移 0x340 - 性能监控计数器中断向量
+	Reserved344         [0x0C]byte // 偏移 0x344-0x34F
+	LvtLINT0            uint32     // 偏移 0x350 - LINT0中断向量
+	Reserved354         [0x0C]byte // 偏移 0x354-0x35F
+	LvtLINT1            uint32     // 偏移 0x360 - LINT1中断向量
+	Reserved364         [0x0C]byte // 偏移 0x364-0x36F
+	LvtError            uint32     // 偏移 0x370 - 错误中断向量
+	Reserved374         [0x0C]byte // 偏移 0x374-0x37F
+	InitialCount        uint32     // 偏移 0x380 - 初始计数寄存器
+	Reserved384         [0x0C]byte // 偏移 0x384-0x38F
+	CurrentCount        uint32     // 偏移 0x390 - 当前计数寄存器
+	Reserved394         [0x0C]byte // 偏移 0x394-0x39F
+	Reserved3A0         [0x40]byte // 偏移 0x3A0-0x3DF
+	DivideConfiguration uint32     // 偏移 0x3E0 - 分频配置寄存器
+	Reserved3E4         [0x0C]byte // 偏移 0x3E4-0x3EF
+	SelfIpi             uint32     // 偏移 0x3F0 - 自中断寄存器(X2APIC)
+	Reserved3F4         [0x0C]byte // 偏移 0x3F4-0x3FF(X2APIC保留)
+}
+
+// PLAPIC_PAGE 是指向 LAPIC_PAGE 的指针类型
+type PLAPIC_PAGE *LAPIC_PAGE
+
+const (
+	REGISTER_RAX REGS_ENUM = iota
+	REGISTER_EAX
+	REGISTER_AX
+	REGISTER_AH
+	REGISTER_AL
+	REGISTER_RCX
+	REGISTER_ECX
+	REGISTER_CX
+	REGISTER_CH
+	REGISTER_CL
+	REGISTER_RDX
+	REGISTER_EDX
+	REGISTER_DX
+	REGISTER_DH
+	REGISTER_DL
+	REGISTER_RBX
+	REGISTER_EBX
+	REGISTER_BX
+	REGISTER_BH
+	REGISTER_BL
+	REGISTER_RSP
+	REGISTER_ESP
+	REGISTER_SP
+	REGISTER_SPL
+	REGISTER_RBP
+	REGISTER_EBP
+	REGISTER_BP
+	REGISTER_BPL
+	REGISTER_RSI
+	REGISTER_ESI
+	REGISTER_SI
+	REGISTER_SIL
+	REGISTER_RDI
+	REGISTER_EDI
+	REGISTER_DI
+	REGISTER_DIL
+	REGISTER_R8
+	REGISTER_R8D
+	REGISTER_R8W
+	REGISTER_R8H
+	REGISTER_R8L
+	REGISTER_R9
+	REGISTER_R9D
+	REGISTER_R9W
+	REGISTER_R9H
+	REGISTER_R9L
+	REGISTER_R10
+	REGISTER_R10D
+	REGISTER_R10W
+	REGISTER_R10H
+	REGISTER_R10L
+	REGISTER_R11
+	REGISTER_R11D
+	REGISTER_R11W
+	REGISTER_R11H
+	REGISTER_R11L
+	REGISTER_R12
+	REGISTER_R12D
+	REGISTER_R12W
+	REGISTER_R12H
+	REGISTER_R12L
+	REGISTER_R13
+	REGISTER_R13D
+	REGISTER_R13W
+	REGISTER_R13H
+	REGISTER_R13L
+	REGISTER_R14
+	REGISTER_R14D
+	REGISTER_R14W
+	REGISTER_R14H
+	REGISTER_R14L
+	REGISTER_R15
+	REGISTER_R15D
+	REGISTER_R15W
+	REGISTER_R15H
+	REGISTER_R15L
+	REGISTER_DS
+	REGISTER_ES
+	REGISTER_FS
+	REGISTER_GS
+	REGISTER_CS
+	REGISTER_SS
+	REGISTER_RFLAGS
+	REGISTER_EFLAGS
+	REGISTER_FLAGS
+	REGISTER_CF
+	REGISTER_PF
+	REGISTER_AF
+	REGISTER_ZF
+	REGISTER_SF
+	REGISTER_TF
+	REGISTER_IF
+	REGISTER_DF
+	REGISTER_OF
+	REGISTER_IOPL
+	REGISTER_NT
+	REGISTER_RF
+	REGISTER_VM
+	REGISTER_AC
+	REGISTER_VIF
+	REGISTER_VIP
+	REGISTER_ID
+	REGISTER_RIP
+	REGISTER_EIP
+	REGISTER_IP
+	REGISTER_IDTR
+	REGISTER_LDTR
+	REGISTER_GDTR
+	REGISTER_TR
+	REGISTER_CR0
+	REGISTER_CR2
+	REGISTER_CR3
+	REGISTER_CR4
+	REGISTER_CR8
+	REGISTER_DR0
+	REGISTER_DR1
+	REGISTER_DR2
+	REGISTER_DR3
+	REGISTER_DR6
+	REGISTER_DR7
+)
+
+var RegistersNames = []string{
+	"rax", "eax", "ax", "ah", "al", "rcx", "ecx", "cx",
+	"ch", "cl", "rdx", "edx", "dx", "dh", "dl", "rbx",
+	"ebx", "bx", "bh", "bl", "rsp", "esp", "sp", "spl",
+	"rbp", "ebp", "bp", "bpl", "rsi", "esi", "si", "sil",
+	"rdi", "edi", "di", "dil", "r8", "r8d", "r8w", "r8h",
+	"r8l", "r9", "r9d", "r9w", "r9h", "r9l", "r10", "r10d",
+	"r10w", "r10h", "r10l", "r11", "r11d", "r11w", "r11h", "r11l",
+	"r12", "r12d", "r12w", "r12h", "r12l", "r13", "r13d", "r13w",
+	"r13h", "r13l", "r14", "r14d", "r14w", "r14h", "r14l", "r15",
+	"r15d", "r15w", "r15h", "r15l", "ds", "es", "fs", "gs",
+	"cs", "ss", "rflags", "eflags", "flags", "cf", "pf", "af",
+	"zf", "sf", "tf", "if", "df", "of", "iopl", "nt",
+	"rf", "vm", "ac", "vif", "vip", "id", "rip", "eip",
+	"ip", "idtr", "ldtr", "gdtr", "tr", "cr0", "cr2", "cr3",
+	"cr4", "cr8", "dr0", "dr1", "dr2", "dr3", "dr6", "dr7",
+}
Index: hyperdbg/libhyperdbg/libhyperdbg.vcxproj
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/libhyperdbg/libhyperdbg.vcxproj b/hyperdbg/libhyperdbg/libhyperdbg.vcxproj
--- a/hyperdbg/libhyperdbg/libhyperdbg.vcxproj	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/libhyperdbg/libhyperdbg.vcxproj	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -209,6 +209,7 @@
     <ClCompile Include="code\debugger\user-level\ud.cpp" />
     <ClCompile Include="code\debugger\user-level\user-listening.cpp" />
     <ClCompile Include="code\export\export.cpp" />
+    <ClCompile Include="code\export\mcp.cpp" />
     <ClCompile Include="code\hwdbg\hwdbg-interpreter.cpp" />
     <ClCompile Include="code\hwdbg\hwdbg-scripts.cpp" />
     <ClCompile Include="code\objects\objects.cpp" />
Index: hyperdbg/script-engine/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/script-engine/CMakeLists.txt b/hyperdbg/script-engine/CMakeLists.txt
--- a/hyperdbg/script-engine/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/script-engine/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -3,18 +3,20 @@
     "../include/platform/user/header/Environment.h"
     "header/common.h"
     "header/globals.h"
+    "header/hardware.h"
     "header/parse-table.h"
+    "header/pch.h"
     "header/scanner.h"
     "header/script-engine.h"
     "header/type.h"
-    "pch.h"
     "code/common.c"
     "code/globals.c"
+    "code/hardware.c"
     "code/parse-table.c"
+    "code/pch.c"
     "code/scanner.c"
     "code/script-engine.c"
     "code/type.c"
-    "pch.c"
 )
 include_directories(
     "header"
@@ -22,4 +24,4 @@
     "."
     "../script-eval"
 )
-add_library(script-engine SHARED ${SourceFiles})
+add_library(script_engine SHARED ${SourceFiles})
Index: hyperdbg/symbol-parser/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hyperdbg/symbol-parser/CMakeLists.txt b/hyperdbg/symbol-parser/CMakeLists.txt
--- a/hyperdbg/symbol-parser/CMakeLists.txt	(revision 891382fa50b07fd7148777089bb4167f4032b69d)
+++ b/hyperdbg/symbol-parser/CMakeLists.txt	(revision 9d4c90734a01c64574af91d753dc819ec7d5c00a)
@@ -14,4 +14,4 @@
     "../dependencies"
     "."
 )
-add_library(symbol-parser SHARED ${SourceFiles})
+add_library(symbol_parser SHARED ${SourceFiles})
